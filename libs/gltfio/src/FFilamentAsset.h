/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef GLTFIO_FFILAMENTASSET_H
#define GLTFIO_FFILAMENTASSET_H

#include <gltfio/FilamentAsset.h>
#include <gltfio/NodeManager.h>
#include <gltfio/TrsTransformManager.h>

#include <filament/Engine.h>
#include <filament/IndexBuffer.h>
#include <filament/MaterialInstance.h>
#include <filament/RenderableManager.h>
#include <filament/Texture.h>
#include <filament/TextureSampler.h>
#include <filament/TransformManager.h>
#include <filament/VertexBuffer.h>

#include <gltfio/MaterialProvider.h>
#include <gltfio/TextureProvider.h>

#include <math/mat4.h>

#include <utils/FixedCapacityVector.h>
#include <utils/CString.h>
#include <utils/Entity.h>

#include <cgltf.h>

#include "downcast.h"
#include "DependencyGraph.h"
#include "DracoCache.h"
#include "FFilamentInstance.h"
#include "Utility.h"

#include <string>
#include <unordered_map>
#include <variant>
#include <vector>

#ifdef NDEBUG
#define GLTFIO_VERBOSE 0
#define GLTFIO_WARN(msg)
#else
#define GLTFIO_VERBOSE 1
#define GLTFIO_WARN(msg) slog.w << msg << io::endl
#endif

#if defined(__EMSCRIPTEN__) || defined(__ANDROID__) || defined(IOS)
#define GLTFIO_USE_FILESYSTEM 0
#else
#define GLTFIO_USE_FILESYSTEM 1
#endif

namespace utils {
    class NameComponentManager;
    class EntityManager;
}

namespace filament::gltfio {

struct Wireframe;

// Stores a connection between Texture and MaterialInstance; consumed by resource loader so that it
// can call "setParameter" on the given MaterialInstance after the Texture has been created.
// Since material instances are not typically shared between FilamentInstance, the slots are a
// unified list across all instances that exist before creation of Texture objects.
struct TextureSlot {
    MaterialInstance* materialInstance;
    const char* materialParameter;
};

// MeshCache
// ---------
// If a given glTF mesh is referenced by multiple glTF nodes, then it generates a separate Filament
// renderable for each of those nodes. All renderables generated by a given mesh share a common set
// of VertexBuffer and IndexBuffer objects. To achieve the sharing behavior, the loader maintains a
// small cache. There is one cache entry per cgltf_mesh. Each entry is a list of primitives, where a
// "primitive" is a reference to a Filament VertexBuffer and IndexBuffer.
struct Primitive {
    VertexBuffer* vertices = nullptr;
    IndexBuffer* indices = nullptr;
    Aabb aabb; // object-space bounding box
    UvMap uvmap; // mapping from each glTF UV set to either UV0 or UV1 (8 bytes)
    MorphTargetBuffer* targets = nullptr;
};
using MeshCache = utils::FixedCapacityVector<utils::FixedCapacityVector<Primitive>>;

struct FFilamentAsset : public FilamentAsset {
    struct ResourceInfo;
    struct ResourceInfoExtended;

    FFilamentAsset(Engine* engine, utils::NameComponentManager* names,
            utils::EntityManager* entityManager, NodeManager* nodeManager,
            TrsTransformManager* trsTransformManager, const cgltf_data* srcAsset,
            bool useExtendedAlgo) :
            mEngine(engine), mNameManager(names), mEntityManager(entityManager),
            mNodeManager(nodeManager), mTrsTransformManager(trsTransformManager),
            mSourceAsset(new SourceAsset {(cgltf_data*)srcAsset}),
            mTextures(srcAsset->textures_count),
            mMeshCache(srcAsset->meshes_count) {
        if (!useExtendedAlgo) {
            mResourceInfo = ResourceInfo{};
        } else {
            mResourceInfo = ResourceInfoExtended{};
        }
    }

    ~FFilamentAsset();

    size_t getEntityCount() const noexcept {
        return mEntities.size();
    }

    const utils::Entity* getEntities() const noexcept {
        return mEntities.empty() ? nullptr : mEntities.data();
    }

    const utils::Entity* getLightEntities() const noexcept {
        return mLightEntities.empty() ? nullptr : mLightEntities.data();
    }

    size_t getLightEntityCount() const noexcept {
        return mLightEntities.size();
    }

    const utils::Entity* getRenderableEntities() const noexcept {
        return (mRenderableCount == 0) ? nullptr : mEntities.data();
    }

    size_t getRenderableEntityCount() const noexcept {
        // Note that mRenderableCount is a "predicted" number of renderables, so if this is a
        // zero-instance asset, then we need to explicitly return zero.
        return mEntities.empty() ? 0 : mRenderableCount;
    }

    const utils::Entity* getCameraEntities() const noexcept {
        return mCameraEntities.empty() ? nullptr : mCameraEntities.data();
    }

    size_t getCameraEntityCount() const noexcept {
        return mCameraEntities.size();
    }

    utils::Entity getRoot() const noexcept {
        return mRoot;
    }

    size_t popRenderables(utils::Entity* entities, size_t count) noexcept {
        return mDependencyGraph.popRenderables(entities, count);
    }

    size_t getResourceUriCount() const noexcept {
        return mResourceUris.size();
    }

    const char* const* getResourceUris() const noexcept {
        return mResourceUris.data();
    }

    Aabb getBoundingBox() const noexcept {
        return mBoundingBox;
    }

    const char* getName(utils::Entity entity) const noexcept;

    const char* getExtras(utils::Entity entity) const noexcept;

    utils::Entity getFirstEntityByName(const char* name) noexcept;

    size_t getEntitiesByName(const char* name, utils::Entity* entities,
            size_t maxCount) const noexcept;

    size_t getEntitiesByPrefix(const char* prefix, utils::Entity* entities,
            size_t maxCount) const noexcept;

    const char* getMorphTargetNameAt(utils::Entity entity, size_t targetIndex) const noexcept;

    size_t getMorphTargetCountAt(utils::Entity entity) const noexcept;

    utils::Entity getWireframe() noexcept;

    Engine* getEngine() const noexcept {
        return mEngine;
    }

    TrsTransformManager* getTrsTransformManager() const noexcept {
        return mTrsTransformManager;
    }

    void releaseSourceData() noexcept;

    const void* getSourceAsset() const noexcept {
        return mSourceAsset.get() ? mSourceAsset->hierarchy : nullptr;
    }

    FilamentInstance** getAssetInstances() noexcept {
        return (FilamentInstance**) mInstances.data();
    }

    size_t getAssetInstanceCount() const noexcept {
        return mInstances.size();
    }

    size_t getSceneCount() const noexcept { return mScenes.size(); }

    const char* getSceneName(size_t sceneIndex) const noexcept {
        return mScenes[sceneIndex].c_str();
    }

    void addEntitiesToScene(Scene& targetScene, const Entity* entities, size_t count,
            SceneMask sceneFilter) const;

    void detachFilamentComponents() noexcept {
        mDetachedFilamentComponents = true;
    }

    bool isUsingExtendedAlgorithm() {
        return std::holds_alternative<ResourceInfoExtended>(mResourceInfo);
    }

    // end public API

    // If a Filament Texture for the given args already exists, calls setParameter() and returns
    // early. If the Texture doesn't exist yet, stashes binding information for later.
    void addTextureBinding(MaterialInstance* materialInstance, const char* parameterName,
        const cgltf_texture* srcTexture, TextureProvider::TextureFlags flags);

    // Calls mi->setParameter() for the given texture slot and optionally adds an edge
    // to the dependency graph used for gradual reveal of entities.
    void applyTextureBinding(size_t textureIndex,const TextureSlot& tb, bool addDependency = true);

    struct Skin {
        utils::CString name;
        utils::FixedCapacityVector<math::mat4f> inverseBindMatrices;
    };

    Engine* const mEngine;
    utils::NameComponentManager* const mNameManager;
    utils::EntityManager* const mEntityManager;
    NodeManager* const mNodeManager;
    TrsTransformManager* const mTrsTransformManager;
    std::vector<utils::Entity> mEntities; // sorted such that renderables come first
    std::vector<utils::Entity> mLightEntities;
    std::vector<utils::Entity> mCameraEntities;
    size_t mRenderableCount = 0;
    std::vector<VertexBuffer*> mVertexBuffers;
    std::vector<BufferObject*> mBufferObjects;
    std::vector<IndexBuffer*> mIndexBuffers;
    std::vector<MorphTargetBuffer*> mMorphTargetBuffers;
    utils::FixedCapacityVector<Skin> mSkins;
    utils::FixedCapacityVector<utils::CString> mScenes;
    Aabb mBoundingBox;
    utils::Entity mRoot;
    std::vector<FFilamentInstance*> mInstances;
    Wireframe* mWireframe = nullptr;

    // Indicates if resource decoding has started (not necessarily finished)
    bool mResourcesLoaded = false;

    DependencyGraph mDependencyGraph;
    std::unordered_map<std::string, std::vector<utils::Entity>> mNameToEntity;
    utils::CString mAssetExtras;
    bool mDetachedFilamentComponents = false;

    // Sentinels for situations where ResourceLoader needs to generate data.
    const cgltf_accessor mGenerateNormals = {};
    const cgltf_accessor mGenerateTangents = {};

    // Encapsulates reference-counted source data, which includes the cgltf hierachy
    // and potentially also includes buffer data that can be uploaded to the GPU.
    struct SourceAsset {
        ~SourceAsset() { cgltf_free(hierarchy); }
        cgltf_data* hierarchy;
        DracoCache dracoCache;
        utils::FixedCapacityVector<uint8_t> glbData;
    };

    // We used shared ownership for the raw cgltf data in order to permit ResourceLoader to
    // complete various asynchronous work (e.g. uploading buffers to the GPU) even after the asset
    // or ResourceLoader have been destroyed.
    using SourceHandle = std::shared_ptr<SourceAsset>;
    SourceHandle mSourceAsset;

    // The mapping of root nodes to scene membership sets.
    tsl::robin_map<cgltf_node*, SceneMask> mRootNodes;

    // Stores all information related to a single cgltf_texture.
    // Note that more than one cgltf_texture can map to a single Filament texture,
    // e.g. if several have the same URL or bufferView. For each Filament texture,
    // only one of its corresponding TextureInfo slots will have isOwner=true.
    struct TextureInfo {
        std::vector<TextureSlot> bindings;
        Texture* texture;
        TextureProvider::TextureFlags flags;
        bool isOwner;
    };

    // Mapping from cgltf_texture to Texture* is required when creating new instances.
    utils::FixedCapacityVector<TextureInfo> mTextures;

    // Resource URIs can be queried by the end user.
    utils::FixedCapacityVector<const char*> mResourceUris;

    // The mapping from cgltf_mesh to VertexBuffer* (etc) is required when creating new instances.
    MeshCache mMeshCache;

    // Asset information that is produced by AssetLoader and consumed by ResourceLoader:
    struct ResourceInfo {
        // Encapsulates VertexBuffer::setBufferAt() or IndexBuffer::setBuffer().
        struct BufferSlot {
            const cgltf_accessor* accessor;
            cgltf_attribute_type attribute;
            int bufferIndex;// for vertex buffer and morph target buffer only
            VertexBuffer* vertexBuffer;
            IndexBuffer* indexBuffer;
            MorphTargetBuffer* morphTargetBuffer;
        };

        std::vector<BufferSlot> mBufferSlots;
        std::vector<std::pair<const cgltf_primitive*, VertexBuffer*>> mPrimitives;
    };
    struct ResourceInfoExtended {
        // Used to denote a generated buffer. Set as `index in `CgltfAttribute`.
        static constexpr int const GENERATED_0_INDEX = -1;
        static constexpr int const GENERATED_1_INDEX = -2;

        struct BufferSlot {
            VertexBuffer* vertices = nullptr;
            IndexBuffer* indices = nullptr;
            MorphTargetBuffer* target = nullptr;
            int slot = -1;
            size_t sizeInBytes = 0;

            void* data = nullptr;

            // MorphTarget-only data;
            struct {
                short4* tbn = nullptr;
                float3* positions = nullptr;
            } targetData;
        };

        std::vector<BufferSlot> slots;

        // This is to workaround the fact that the original ResourceLoader owns the UriDataCache. In
        // the extended implementation, we create it in AssetLoader. We pass it along to
        // ResourceLoader here.
        UriDataCacheHandle uriDataCache;
    };

    std::variant<ResourceInfo, ResourceInfoExtended> mResourceInfo;
};

FILAMENT_DOWNCAST(FilamentAsset)

} // namespace filament::gltfio

#endif // GLTFIO_FFILAMENTASSET_H
