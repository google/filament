<!DOCTYPE html>
<html lang="en">

<head>
  <title>Filament Cube</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1">
  <link href="favicon.png" rel="icon" type="image/x-icon" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      touch-action: none;
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>
  <canvas></canvas>
  <script src="filament.js"></script>
  <script src="gl-matrix-min.js"></script>
  <script>

    Filament.init(['nonlit_fl0.filamat'], () => {
      window.VertexAttribute = Filament.VertexAttribute;
      window.AttributeType = Filament.VertexBuffer$AttributeType;
      window.Projection = Filament.Camera$Projection;
      window.Fov = Filament.Camera$Fov;
      window.app = new App(document.getElementsByTagName('canvas')[0]);
    });

    class App {
      constructor(canvas) {
        this.canvas = canvas;
        const engine = this.engine = Filament.Engine.create(this.canvas, {}, { forceGLES2Context: true });
        console.log("Engine Config forceGLES2Context:", engine.getConfig().forceGLES2Context);
        this.scene = engine.createScene();
        this.cube = Filament.EntityManager.get().create();
        this.scene.addEntity(this.cube);

        const CUBE_POSITIONS = new Float32Array([
          // Front face
          -1.0, -1.0, 1.0,
          1.0, -1.0, 1.0,
          1.0, 1.0, 1.0,
          -1.0, 1.0, 1.0,

          // Back face
          -1.0, -1.0, -1.0,
          -1.0, 1.0, -1.0,
          1.0, 1.0, -1.0,
          1.0, -1.0, -1.0,

          // Top face
          -1.0, 1.0, -1.0,
          -1.0, 1.0, 1.0,
          1.0, 1.0, 1.0,
          1.0, 1.0, -1.0,

          // Bottom face
          -1.0, -1.0, -1.0,
          1.0, -1.0, -1.0,
          1.0, -1.0, 1.0,
          -1.0, -1.0, 1.0,

          // Right face
          1.0, -1.0, -1.0,
          1.0, 1.0, -1.0,
          1.0, 1.0, 1.0,
          1.0, -1.0, 1.0,

          // Left face
          -1.0, -1.0, -1.0,
          -1.0, -1.0, 1.0,
          -1.0, 1.0, 1.0,
          -1.0, 1.0, -1.0,
        ]);

        const CUBE_COLORS = new Uint32Array([
          // Front face (red)
          0xff0000ff, 0xff0000ff, 0xff0000ff, 0xff0000ff,
          // Back face (green)
          0xff00ff00, 0xff00ff00, 0xff00ff00, 0xff00ff00,
          // Top face (blue)
          0xffff0000, 0xffff0000, 0xffff0000, 0xffff0000,
          // Bottom face (yellow)
          0xff00ffff, 0xff00ffff, 0xff00ffff, 0xff00ffff,
          // Right face (magenta)
          0xffff00ff, 0xffff00ff, 0xffff00ff, 0xffff00ff,
          // Left face (cyan)
          0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
        ]);

        const CUBE_INDICES = new Uint16Array([
          0, 1, 2, 0, 2, 3,    // front
          4, 5, 6, 4, 6, 7,    // back
          8, 9, 10, 8, 10, 11,    // top
          12, 13, 14, 12, 14, 15,    // bottom
          16, 17, 18, 16, 18, 19,    // right
          20, 21, 22, 20, 22, 23,    // left
        ]);

        this.vb = Filament.VertexBuffer.Builder()
          .vertexCount(24)
          .bufferCount(2)
          .attribute(VertexAttribute.POSITION, 0, AttributeType.FLOAT3, 0, 12)
          .attribute(VertexAttribute.COLOR, 1, AttributeType.UBYTE4, 0, 4)
          .normalized(VertexAttribute.COLOR)
          .build(engine);

        this.vb.setBufferAt(engine, 0, CUBE_POSITIONS);
        this.vb.setBufferAt(engine, 1, CUBE_COLORS);

        this.ib = Filament.IndexBuffer.Builder()
          .indexCount(36)
          .bufferType(Filament.IndexBuffer$IndexType.USHORT)
          .build(engine);

        this.ib.setBuffer(engine, CUBE_INDICES);

        const mat = engine.createMaterial('nonlit_fl0.filamat');
        const matinst = mat.getDefaultInstance();
        Filament.RenderableManager.Builder(1)
          .boundingBox({ center: [-1, -1, -1], halfExtent: [1, 1, 1] })
          .material(0, matinst)
          .geometry(0, Filament.RenderableManager$PrimitiveType.TRIANGLES, this.vb, this.ib)
          .build(engine, this.cube);

        this.swapChain = engine.createSwapChain();
        this.renderer = engine.createRenderer();
        this.camera = engine.createCamera(Filament.EntityManager.get().create());

        this.view = engine.createView();
        this.view.setSampleCount(4);
        this.view.setCamera(this.camera);
        this.view.setScene(this.scene);
        this.view.setPostProcessingEnabled(false);

        this.renderer.setClearOptions({ clearColor: [0.0, 0.1, 0.2, 1.0], clear: true });

        this.resize();
        this.render = this.render.bind(this);
        this.resize = this.resize.bind(this);
        window.addEventListener('resize', this.resize);
        window.requestAnimationFrame(this.render);
      }

      render() {
        const radians = Date.now() / 1000;

        // Combine rotations around Y and X axes for a spinning effect
        const transformY = mat4.fromRotation(mat4.create(), radians, [0, 1, 0]);
        const transformX = mat4.fromRotation(mat4.create(), radians * 0.5, [1, 0, 0]);
        const transform = mat4.multiply(mat4.create(), transformY, transformX);

        const tcm = this.engine.getTransformManager();
        const inst = tcm.getInstance(this.cube);
        tcm.setTransform(inst, transform);
        inst.delete();

        this.renderer.render(this.swapChain, this.view);
        window.requestAnimationFrame(this.render);
      }

      resize() {
        const dpr = window.devicePixelRatio;
        const width = this.canvas.width = window.innerWidth * dpr;
        const height = this.canvas.height = window.innerHeight * dpr;
        this.view.setViewport([0, 0, width, height]);

        const eye = [0, 0, 5], center = [0, 0, 0], up = [0, 1, 0];
        this.camera.lookAt(eye, center, up);

        const aspect = width / height;
        const fov = aspect < 1 ? Fov.HORIZONTAL : Fov.VERTICAL;
        this.camera.setProjectionFov(90, aspect, 1.0, 10.0, fov);
      }
    }
  </script>
</body>

</html>