material {
    name : Skybox,
    parameters : [
        {
           type : int,
           name : showSun
        },
        {
           type : int,
           name : skyboxType
        },
        {
           type : samplerCubemap,
           name : skybox
        },
        {
           type : float4,
           name : color
        },
        {
           type : float,
           name : uiScaleFactor
        },
        {
           type : int,
           name : upDirectionAxis
        },
        {
           type : float2,
           name : checkerboardGrays
        },
        {
           type : float4,
           name : gradientSettings
        }
    ],
    variables : [
         eyeDirection
    ],
    vertexDomain : device,
    depthWrite : false,
    shadingModel : unlit,
    variantFilter : [ skinning, shadowReceiver ],
    culling: none
}

fragment {

#define SHAPR_SKYBOX_TYPE_SOLID_COLOR 0
#define SHAPR_SKYBOX_TYPE_GRADIENT 1
#define SHAPR_SKYBOX_TYPE_ENVIRONMENT 2
#define SHAPR_SKYBOX_TYPE_CHECKERBOARD 3

    float3 approxInverseSRGB(float3 srgb) {
        return pow(srgb, vec3(2.2));
    }

    // Creates a checkerboard pattern of repeats fields in uv (must be in [0,1])
    // Source: https://github.com/mattdesl/glsl-checker
    float checker(float2 uv, float2 repeats) {
        float cx = floor(repeats.x * uv.x);
        float cy = floor(repeats.y * uv.y); 
        float result = mod(cx + cy, 2.0);
        return sign(result);
    }

    float3 shaprCheckerboardPattern(float2 positionScaledClipSpace) {
        float colorLight = materialParams.checkerboardGrays.x;
        float colorDark = materialParams.checkerboardGrays.y;

        // Size of a square in pixels
        float2 squareSizePixels = float2(8.0, 8.0) * max(materialParams.uiScaleFactor, 1.0);

        float pattern = checker(positionScaledClipSpace, getResolution().xy / squareSizePixels);
        float resultColor = mix(colorLight, colorDark, pattern);
        return float3(resultColor, resultColor, resultColor);
    }

    // Conversion code from: https://bottosson.github.io/posts/oklab/
    float3 linear_srgb_to_oklab(float3 c) 
    {
        float l = 0.4122214708 * c.r + 0.5363325363 * c.g + 0.0514459929 * c.b;
        float m = 0.2119034982 * c.r + 0.6806995451 * c.g + 0.1073969566 * c.b;
        float s = 0.0883024619 * c.r + 0.2817188376 * c.g + 0.6299787005 * c.b;

        float l_ = pow(l, 1.0/3.0);
        float m_ = pow(m, 1.0/3.0);
        float s_ = pow(s, 1.0/3.0);

        return float3(
            0.2104542553*l_ + 0.7936177850*m_ - 0.0040720468*s_,
            1.9779984951*l_ - 2.4285922050*m_ + 0.4505937099*s_,
            0.0259040371*l_ + 0.7827717662*m_ - 0.8086757660*s_
        );
    }

    float3 oklab_to_linear_srgb(float3 c) 
    {
        float l_ = c.r + 0.3963377774 * c.g + 0.2158037573 * c.b;
        float m_ = c.r - 0.1055613458 * c.g - 0.0638541728 * c.b;
        float s_ = c.r - 0.0894841775 * c.g - 1.2914855480 * c.b;

        float l = l_*l_*l_;
        float m = m_*m_*m_;
        float s = s_*s_*s_;

        return float3(
            +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s,
            -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s,
            -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s
        );
    }

    float computeGradient(float t) {
        float dimmingFactor = materialParams.gradientSettings.x;
        float gradientStartHigh = materialParams.gradientSettings.y;
        float gradientLocation = materialParams.gradientSettings.z;
        float gradientStartLow = materialParams.gradientSettings.w;

        float grad;
        if (t >= gradientLocation) {
            grad = dimmingFactor + (t - gradientLocation) * (1.0 / (gradientStartHigh - gradientLocation)) * (1.0 - dimmingFactor);
        } else {
            grad = 1.0 - (t - gradientStartLow) * (1.0 / (gradientLocation - gradientStartLow)) * (1.0 - dimmingFactor);
        }
        return saturate(grad);
    }

    float3 shaprSkyGradient() {
        const float shaprThreshold = 0.5;

        float upDirectionAlongAxis = materialParams.upDirectionAxis == 0 ? normalize(variable_eyeDirection).y : normalize(variable_eyeDirection).z;
        float upDirectionMapped = upDirectionAlongAxis * 0.5 + 0.5;
        float3 colorRGB = approxInverseSRGB(materialParams.color.rgb);
        float3 colorOklab = linear_srgb_to_oklab(colorRGB);
        if (colorOklab.r > shaprThreshold) {
            // oklab.r is the luminance channel
            colorOklab.r *= computeGradient(upDirectionMapped);
        } else {
            const float shaprDarkColorsBias = 2.0;
            // oklab.r is the luminance channel
            colorOklab.r *= (shaprDarkColorsBias - computeGradient(upDirectionMapped));
        }
        return oklab_to_linear_srgb(colorOklab);
    }

    void material(inout MaterialInputs material) {
        prepareMaterial(material);
        float4 sky;
        if (materialParams.skyboxType == SHAPR_SKYBOX_TYPE_SOLID_COLOR) {
            sky = float4(approxInverseSRGB(materialParams.color.rgb), materialParams.color.a);
        } else if (materialParams.skyboxType == SHAPR_SKYBOX_TYPE_GRADIENT) {
            float3 shaprSkyColor = shaprSkyGradient();
            sky = float4(shaprSkyColor, 1.0);
        } else if (materialParams.skyboxType == SHAPR_SKYBOX_TYPE_ENVIRONMENT) {
            sky = float4(textureLod(materialParams_skybox, variable_eyeDirection.xyz, 0.0).rgb, 1.0);
            sky.rgb *= frameUniforms.iblLuminance;
        } else if (materialParams.skyboxType == SHAPR_SKYBOX_TYPE_CHECKERBOARD) {
            float3 checkerboardColor = shaprCheckerboardPattern(getNormalizedViewportCoord().xy);
            sky = float4(checkerboardColor, 1.0);
        } else {
            sky = float4(1.0, 0.0, 1.0, 1.0);
        }

        if (materialParams.skyboxType == SHAPR_SKYBOX_TYPE_ENVIRONMENT && materialParams.showSun != 0 && frameUniforms.sun.w >= 0.0f) {
            float3 direction = normalize(variable_eyeDirection.xyz);
            // Assume the sun is a sphere
            float3 sun = frameUniforms.lightColorIntensity.rgb *
                    (frameUniforms.lightColorIntensity.a * (4.0 * PI));
            float cosAngle = dot(direction, frameUniforms.lightDirection);
            float x = (cosAngle - frameUniforms.sun.x) * frameUniforms.sun.z;
            float gradient = pow(1.0 - saturate(x), frameUniforms.sun.w);
            sky.rgb = sky.rgb + gradient * sun;
        }

        if (materialParams.skyboxType != SHAPR_SKYBOX_TYPE_ENVIRONMENT) {
            material.baseColor = float4(0.0);
            material.postLightingColor = saturate(sky);
        } else {
            material.baseColor = sky;
        }
    }
}

vertex {
    void materialVertex(inout MaterialVertexInputs material) {
        float3 p = getPosition().xyz;
        float3 unprojected = mulMat4x4Float3(getViewFromClipMatrix(), p).xyz;
        material.eyeDirection.xyz = mulMat3x3Float3(getWorldFromViewMatrix(), unprojected);
    }
}
