material {
    name : taa,
    parameters : [
        {
            type : sampler2d,
            name : color
        },
        {
            type : sampler2d,
            name : depth,
            precision: high,
            filterable: false
        },
        {
            type : float4,
            name : colorViewport,
            precision: high
        },
        {
            type : sampler2d,
            name : history
        },
        {
            type : float,
            name : alpha
        },
        {
            type : mat4,
            name : reprojection,
            precision: high
        },
        {
            type : float2,
            name : jitter,
            precision: high
        },
        {
            type : float,
            name : scale,
            precision: high
        },
        {
            type : float4,
            name : colorResolution,
            precision: high
        },
        {
            type : float4,
            name : historyResolution,
            precision: high
        }
    ],
    constants : [
        {
            type : bool,
            name : upscaling,
            default : false
        },
        {
            type : bool,
            name : historyReprojection,
            default : true
        },
        {
            type : bool,
            name : filterHistory,
            default : true
        },
        {
            type : bool,
            name : filterInput,
            default : true
        },
        {
            type : int,
            name : boxClipping,
            default : 0
        },
        {
            type : int,
            name : boxType,
            default : 1
        },
        {
            type : bool,
            name : useYCoCg,
            default : false
        },
        {
            type : bool,
            name : preventFlickering,
            default : false
        },
        {
            type : bool,
            name : hdr,
            default : true
        },
        {
            type : float,
            name : varianceGamma,
            default : 1.0
        }
    ],
    variables : [
        vertex
    ],
    domain : postprocess,
    depthWrite : false,
    depthCulling : false
}

vertex {
    void postProcessVertex(inout PostProcessVertexInputs postProcess) {
        highp vec2 uv = postProcess.normalizedUV;
        // input UVs
        //postProcess.vertex.xy = uvToRenderTargetUV(
        //        materialParams.colorViewport.xy + uv * materialParams.colorViewport.zw);
        postProcess.vertex.xy = uvToRenderTargetUV(uv);
        // history UVs
        postProcess.vertex.zw = uvToRenderTargetUV(uv);
    }
}

fragment {

/* Clipping box type */

// min/max neighborhood
#define BOX_TYPE_AABB           0
// uses both min/max and variance
#define BOX_TYPE_AABB_VARIANCE  1

/* Clipping algorithm */

// accurate box clipping
#define BOX_CLIPPING_ACCURATE   0
// clamping instead of clipping
#define BOX_CLIPPING_CLAMP      1
// no clipping (for debugging only)
#define BOX_CLIPPING_NONE       2

float rcp(float x) {
    return 1.0 / x;
}

float lumaRGB(const vec3 c) {
    return luminance(c);
}

float lumaYCoCg(const vec3 c) {
    return c.x;
}

float luma(const vec3 c, const bool isYcoCg) {
    return isYcoCg ? lumaYCoCg(c) : lumaRGB(c);
}

vec3 tonemap(const vec3 c) {
    return c * rcp(1.0 + max3(c));
}

vec4 tonemap(const vec4 c) {
    return vec4(c.rgb * rcp(1.0 + max3(c.rgb)), c.a);
}

vec3 tonemap(const float w, const vec3 c) {
    return c * (w * rcp(1.0 + max3(c)));
}

vec4 tonemap(const float w, const vec4 c) {
    return vec4(c.rgb * (w * rcp(1.0 + max3(c.rgb))), c.a);
}

vec3 untonemap(const vec3 c) {
    const float epsilon = 1.0 / 65504.0;
    return c * rcp(max(epsilon, 1.0 - max3(c)));
}

// 1-D Lanczos-2 approximation, input is squared and must be [-4, 4]
float lanczos2_SquaredInputApproximate(highp float x2) {
    highp float wA = x2 - 4.0;
    highp float wB = x2 * wA - wA;
    wA *= wA;
    wB *= wA;
    return wB * (1.0 / 64.0);
}

// 1-D Lanczos-2 filter, input must be [-2, 2]
float lanczos2(float v) {
    return lanczos2_SquaredInputApproximate(v * v);
}

// 1-D Lanczos-2 filter, input must be [-2, 2]
float lanczos2(float v, float scale) {
    if (materialConstants_upscaling) {
        v = clamp(v * scale, -2.0, 2.0);
    }
    return lanczos2(v);
}

vec3 RGB_YCoCg(const vec3 c) {
    float Y  = dot(c.rgb, vec3( 1, 2,  1) * 0.25);
    float Co = dot(c.rgb, vec3( 2, 0, -2) * 0.25);
    float Cg = dot(c.rgb, vec3(-1, 2, -1) * 0.25);
    return vec3(Y, Co, Cg);
}

vec3 YCoCg_RGB(const vec3 c) {
    float Y  = c.x;
    float Co = c.y;
    float Cg = c.z;
    float r = Y + Co - Cg;
    float g = Y + Cg;
    float b = Y - Co - Cg;
    return vec3(r, g, b);
}

// clip the (c, h) segment to a box
vec4 clipToBox(const int quality,
        const vec3 boxmin,  const vec3 boxmax, const vec4 c, const vec4 h) {
    const float epsilon = 0.0001;

    if (quality == BOX_CLIPPING_ACCURATE) {
        // don't clip if we're already in the box
        if (any(lessThan(h.rgb, boxmin)) || any(greaterThan(h.rgb, boxmax))) {
            vec4 r = c - h;
            vec3 ir = 1.0 / (epsilon + r.rgb);
            vec3 rmax = (boxmax - h.rgb) * ir;
            vec3 rmin = (boxmin - h.rgb) * ir;
            vec3 imin = min(rmax, rmin);
            return h + r * saturate(max3(imin));
        }
    } else if (quality == BOX_CLIPPING_CLAMP) {
        return vec4(clamp(h.rgb, boxmin, boxmax), h.a);
    }
    return h;
}

// Samples a texture with Catmull-Rom filtering, using 9 texture fetches instead of 16.
//      https://therealmjp.github.io/
//
// Some optimizations from here:
//      http://vec3.ca/bicubic-filtering-in-fewer-taps/ for more details
//
// Optimized to 5 taps by removing the corner samples
//      Jorge Jimenez, SIGGRAPH 2016, Filmic SMAA
//      http://advances.realtimerendering.com/s2016/Filmic%20SMAA%20v7.pptx
//
// And modified for mediump support + deringing
//
vec4 sampleTextureCatmullRom(const sampler2D tex, const highp vec2 uv, const highp vec4 texSize) {
    // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate.
    // We'll do this by rounding down the sample location to get the exact center of our "starting"
    // texel. The starting texel will be at location [1, 1] in the grid, where [0, 0] is the
    // top left corner.

    highp vec2 samplePos = uv * texSize.xy;
    highp vec2 texPos1 = floor(samplePos - 0.5) + 0.5;

    // Compute the fractional offset from our starting texel to our original sample location,
    // which we'll feed into the Catmull-Rom spline function to get our filter weights.
    highp vec2 f = samplePos - texPos1;
    highp vec2 f2 = f * f;
    highp vec2 f3 = f2 * f;

    // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.
    // These equations are pre-expanded based on our knowledge of where the texels will be located,
    // which lets us avoid having to evaluate a piece-wise function.
    vec2 w0 = f2 - 0.5 * (f3 + f);
    vec2 w1 = 1.5 * f3 - 2.5 * f2 + 1.0;
    vec2 w3 = 0.5 * (f3 - f2);
    vec2 w2 = 1.0 - w0 - w1 - w3;

    // Work out weighting factors and sampling offsets that will let us use bilinear filtering to
    // simultaneously evaluate the middle 2 samples from the 4x4 grid.
    vec2 w12 = w1 + w2;

    // Compute the final UV coordinates we'll use for sampling the texture
    highp vec2 texPos0 = texPos1 - vec2(1.0);
    highp vec2 texPos3 = texPos1 + vec2(2.0);
    highp vec2 texPos12 = texPos1 + w2 / w12;

    highp vec2 invTexSize = texSize.zw;
    texPos0  *= invTexSize;
    texPos3  *= invTexSize;
    texPos12 *= invTexSize;

    float k0 = w12.x * w0.y;
    float k1 = w0.x  * w12.y;
    float k2 = w12.x * w12.y;
    float k3 = w3.x  * w12.y;
    float k4 = w12.x * w3.y;

    vec4 s[5];
    s[0] = textureLod(tex, vec2(texPos12.x, texPos0.y),  0.0);
    s[1] = textureLod(tex, vec2(texPos0.x,  texPos12.y), 0.0);
    s[2] = textureLod(tex, vec2(texPos12.x, texPos12.y), 0.0);
    s[3] = textureLod(tex, vec2(texPos3.x,  texPos12.y), 0.0);
    s[4] = textureLod(tex, vec2(texPos12.x, texPos3.y),  0.0);

    vec4 result =   k0 * s[0]
                  + k1 * s[1]
                  + k2 * s[2]
                  + k3 * s[3]
                  + k4 * s[4];

    result *= rcp(k0 + k1 + k2 + k3 + k4);

    // deringing...
    vec4 boxmin = min(min(min(s[0], s[1]), min(s[2], s[3])), s[4]);
    vec4 boxmax = max(max(max(s[0], s[1]), max(s[2], s[3])), s[4]);
    result = clamp(result, boxmin, boxmax);
    return result;
}

const vec2 kInputFilterSampleOffsets[9] = vec2[9](
        vec2( 0,  0),
        vec2( 0, -1), vec2(-1,  0), vec2( 1,  0), vec2( 0,  1),
        vec2(-1, -1), vec2( 1, -1), vec2(-1,  1), vec2( 1,  1)
);

void postProcess(inout PostProcessInputs postProcess) {
    const bool isColorYCoCg = materialConstants_useYCoCg &&
            materialConstants_boxClipping != BOX_CLIPPING_NONE;

    const bool isHistoryYCoCg = materialConstants_useYCoCg &&
            materialConstants_boxClipping != BOX_CLIPPING_NONE;

    // destination uv interpolated to pixel center
    highp vec4 uv = variable_vertex;

    if (materialConstants_historyReprojection) {
        // read the depth buffer center sample for reprojection
        highp float depth = textureLod(materialParams_depth, uv.xy, 0.0).r;
        // reproject history to current frame
        uv.zw = uvToRenderTargetUV(uv.zw);
        highp vec4 q = materialParams.reprojection * vec4(uv.zw, depth, 1.0);
        uv.zw = (q.xy * (1.0 / q.w)) * 0.5 + 0.5;
        uv.zw = uvToRenderTargetUV(uv.zw);
    }

    // read center color and history samples
    vec4 history;
    if (materialConstants_filterHistory) {
        history = sampleTextureCatmullRom(materialParams_history, uv.zw, materialParams.historyResolution);
    } else {
        history = textureLod(materialParams_history, uv.zw, 0.0);
    }

    highp vec2 inputSize = materialParams.colorResolution.xy;
    highp vec2 inputPixelSize = materialParams.colorResolution.zw;

    //    +----------+----------+--
    //    |          |          |
    //    |     o    |    o     |
    //    |          |          |
    //    +----------p----------+--
    //    |          |          |
    //    |     o    |    o     |
    //    |          |        x |
    //    +----------+----------+-
    //    |          |          |
    // o: reconstructed sample
    // x: jittered sample
    // p: texture coordinate of the closest jittered sample from the reconstructed sample

    highp vec2 reconstructedFragmentPos = uv.xy * inputSize;
    highp vec2 closestInputSamplePos = floor(reconstructedFragmentPos - materialParams.jitter) + 0.5;
    highp vec2 p = closestInputSamplePos * inputPixelSize;
    highp vec2 samplePos = closestInputSamplePos + materialParams.jitter;
    vec2 dcenter = samplePos - reconstructedFragmentPos;

    vec4 filtered = textureLod(materialParams_color, p, 0.0);

    float confidence = 1.0;

    if (materialConstants_filterInput ||
            materialConstants_boxClipping != BOX_CLIPPING_NONE) {

        vec3 s[9];
        s[0] = filtered.rgb;
        s[1] = textureLodOffset(materialParams_color, p, 0.0, ivec2( 0, -1)).rgb;
        s[2] = textureLodOffset(materialParams_color, p, 0.0, ivec2(-1,  0)).rgb;
        s[3] = textureLodOffset(materialParams_color, p, 0.0, ivec2( 1,  0)).rgb;
        s[4] = textureLodOffset(materialParams_color, p, 0.0, ivec2( 0,  1)).rgb;
        s[5] = textureLodOffset(materialParams_color, p, 0.0, ivec2(-1, -1)).rgb;
        s[6] = textureLodOffset(materialParams_color, p, 0.0, ivec2( 1, -1)).rgb;
        s[7] = textureLodOffset(materialParams_color, p, 0.0, ivec2(-1,  1)).rgb;
        s[8] = textureLodOffset(materialParams_color, p, 0.0, ivec2( 1,  1)).rgb;

        // the box can be used for deringing or history correction
        vec3 box5min = min(s[0],    min(min(s[1], s[2]), min(s[3], s[4])));
        vec3 box5max = max(s[0],    max(max(s[1], s[2]), max(s[3], s[4])));
        vec3 box9min = min(box5min, min(min(s[5], s[6]), min(s[7], s[8])));
        vec3 box9max = max(box5max, max(max(s[5], s[6]), max(s[7], s[8])));

        if (materialConstants_filterInput) {
            // reconstruct the sample at the center of the current pixel from 3x3 input samples
            // using Lanczos filter. The input sample positions are jittered, so this can also be
            // thought of as "unjittering" the input sample.
            // The distance (in input texels) from the reconstructed sample (uv) to the filter's center sample
            // is given by:
            //     p: texture coordinate of the center input sample
            //     dcenter = (p * inputSize - jitter) - uv * inputSize

            filtered = vec4(vec3(0), filtered.a);
            if (materialConstants_upscaling) {
                // the weigths act as a blending factor because they acount only for a part of the
                // reconstruction filter (for this frame). If the max weight is 0, it doesn't mean we must
                // accumulate black into the history, but it means that these samples have little effect on the
                // final reconstruction.
                confidence = 0.0;
            }

            // The 2D application of the lanczos filter as a separable filter, which is the correct application
            // of lanczos, however it is not isotropic.
            float w0 = lanczos2(dcenter.x - 1.0, materialParams.scale);
            float w1 = lanczos2(dcenter.x,       materialParams.scale);
            float w2 = lanczos2(dcenter.x + 1.0, materialParams.scale);
            float w3 = lanczos2(dcenter.y - 1.0, materialParams.scale);
            float w4 = lanczos2(dcenter.y,       materialParams.scale);
            float w5 = lanczos2(dcenter.y + 1.0, materialParams.scale);
            highp float wx = w0 + w1 + w2;
            highp float wy = w3 + w4 + w5;
            float sum = wx * wy;
            vec3 f;
            f  = s[5] * w0;
            f += s[1] * w1;
            f += s[6] * w2;
            filtered.rgb += f * w3;
            f  = s[2] * w0;
            f += s[0] * w1;
            f += s[3] * w2;
            filtered.rgb += f * w4;
            f  = s[7] * w0;
            f += s[4] * w1;
            f += s[8] * w2;
            filtered.rgb += f * w5;

            // Deringing must happen in RGB, because clamping in YCoCg can produce out-of-gamut colors
            filtered.rgb *= (1.0 / sum);
            filtered.rgb = clamp(filtered.rgb, box9min, box9max);
            if (materialConstants_upscaling) {
                confidence = sum;
            }
        }

        // build the history clamping box
        if (materialConstants_boxClipping != BOX_CLIPPING_NONE) {
            if (materialConstants_useYCoCg) {
                history.xyz = RGB_YCoCg(history.rgb);
                filtered.xyz = RGB_YCoCg(filtered.rgb);
                for (int i = 0; i < 9; i++) {
                    s[i] = RGB_YCoCg(s[i]);
                }
                // recompute the correction box in YCoCg
                box5min = min(s[0],    min(min(s[1], s[2]), min(s[3], s[4])));
                box5max = max(s[0],    max(max(s[1], s[2]), max(s[3], s[4])));
                box9min = min(box5min, min(min(s[5], s[6]), min(s[7], s[8])));
                box9max = max(box5max, max(max(s[5], s[6]), max(s[7], s[8])));
            }
            // give more or less importance to the corner samples by lerp'ing between the two boxes
            vec3 boxmin = mix(box5min, box9min, 0.5);
            vec3 boxmax = mix(box5max, box9max, 0.5);

            if (materialConstants_boxType == BOX_TYPE_AABB_VARIANCE) {
                // "An Excursion in Temporal Supersampling" by Marco Salvi
                highp vec3 m0 = s[0];// conversion to highp
                highp vec3 m1 = m0 * m0;
                // we use only 5 samples instead of all 9
                const int count = 5; // 5 or 9
                for (int i = 1; i < count; i++) {
                    highp vec3 c = s[i];// conversion to highp
                    m0 += c;
                    m1 += c * c;
                }
                highp vec3 a0 = m0 * (1.0 / float(count));
                highp vec3 a1 = m1 * (1.0 / float(count));
                // stdDev is never < 0, but we enforce it with abs(), which is free, to account for fp math
                highp vec3 stdDev = sqrt(abs(a1 - a0 * a0));

                // intersect both bounding boxes
                boxmin = max(boxmin, a0 - materialConstants_varianceGamma * stdDev);
                boxmax = min(boxmax, a0 + materialConstants_varianceGamma * stdDev);
            }
            // history clamping
            history = clipToBox(materialConstants_boxClipping, boxmin, boxmax, filtered, history);
        }
    }

    float alpha = materialParams.alpha * confidence;

    if (materialConstants_preventFlickering) {
        // [Lottes] prevents flickering by modulating the blend weight by the difference in luma
        float lumaColor = luma(filtered.rgb, isColorYCoCg);
        float lumaHistory = luma(history.rgb, isHistoryYCoCg);
        float diff = 1.0 - abs(lumaColor - lumaHistory) / (0.001 + max(lumaColor, lumaHistory));
        alpha *= diff * diff;
    }

    // go back to RGB space before tonemapping
    if (isColorYCoCg) {
        filtered.rgb = YCoCg_RGB(filtered.rgb);
    }
    if (isHistoryYCoCg) {
        history.rgb = YCoCg_RGB(history.rgb);
    }

    if (materialConstants_hdr) {
        // tonemap before mixing
        filtered.rgb = tonemap(filtered.rgb);
        history.rgb = tonemap(history.rgb);
    }

    // combine history and current frame
    vec4 result = mix(history, filtered, alpha);

    if (materialConstants_hdr) {
        // untonemap result
        result.rgb = untonemap(result.rgb);
    }

#if POST_PROCESS_OPAQUE
    // kill the work performed above
    result.a = 1.0;
#endif

    // store result (which will becomes new history)
    postProcess.color = result;
}

}
