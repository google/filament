material {
    name : dofCoc,
    parameters : [
        {
            type : sampler2d,
            name : color,
            precision: medium
        },
        {
            type : sampler2d,
            name : depth,
            precision: medium
        },
        {
            type : float2,
            name : cocParams
        },
        {
            type : float4,
            name : uvscale,
            precision: high
        }
    ],
    variables : [
        vertex
    ],
    outputs : [
        {
            name : color,
            target : color,
            type : float4
        },
        {
            name : background,
            target : color,
            type : float4
        },
        {
            name : cocFgBg,
            target : color,
            type : float2
        }
    ],
    domain : postprocess,
    depthWrite : false,
    depthCulling : false
}

vertex {

    void dummy(){}

    void postProcessVertex(inout PostProcessVertexInputs postProcess) {
        postProcess.vertex.xy = (postProcess.normalizedUV * materialParams.uvscale.xy) * materialParams.uvscale.zw;
    }
}

fragment {

#include "dofUtils.fs"

void dummy(){}

void postProcess(inout PostProcessInputs postProcess) {
    highp vec2 uv = variable_vertex.xy;

    vec4 color = textureLod(materialParams_color, uv, 0.0);
    float d = textureLod(materialParams_depth, uv, 0.0).r;

    // Get the CoC radius.
    // We multiply by 0.5 to convert from diameter to radius.
    float coc = getCOC(d, materialParams.cocParams) * 0.5;

    // If CoC is less that 0.5 full resolution pixel, we clamp to 0, this will reduce
    // artifacts in the "in focus" area and allow us to skip more tiles trivially.
    if (abs(coc) < MAX_IN_FOCUS_COC) {
        coc = 0.0;
    }

    // Clamp to maximum allowable CoC radius.
    coc = clamp(coc, -MAX_COC_RADIUS, MAX_COC_RADIUS);

    // Output to MRTs
    postProcess.color       = color;
    postProcess.background  = color;
    postProcess.cocFgBg     = vec2(coc, coc);
}

}
