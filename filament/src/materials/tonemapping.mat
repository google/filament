material {
    name : tonemap,
    parameters : [
        {
            type : sampler2d,
            name : colorBuffer,
            precision: high
        },
        {
            type : int,
            name : dithering
        }
    ],
    depthWrite : false,
    depthCulling : false,
    culling: none,
    domain: postprocess
}

fragment {

    //------------------------------------------------------------------------------
    // Tone-mapping configuration
    //------------------------------------------------------------------------------

    // Operators for LDR output
#define TONE_MAPPING_UNREAL           0
#define TONE_MAPPING_FILMIC_ALU       1
#define TONE_MAPPING_LINEAR           2 // Operators with built-in sRGB go above
#define TONE_MAPPING_REINHARD         3
#define TONE_MAPPING_ACES             4

    // Operators for HDR output
#define TONE_MAPPING_ACES_REC2020_1K  5

    // Debug operators
#define TONE_MAPPING_DISPLAY_RANGE    9

#ifdef TARGET_MOBILE
        #define TONE_MAPPING_OPERATOR     TONE_MAPPING_UNREAL
#else
        #define TONE_MAPPING_OPERATOR     TONE_MAPPING_ACES
#endif

    //------------------------------------------------------------------------------
    // Tone-mapping operators for LDR output
    //------------------------------------------------------------------------------

    vec3 Tonemap_Linear(const vec3 x) {
        return x;
    }

    vec3 Tonemap_Reinhard(const vec3 x) {
        // Reinhard et al. 2002, "Photographic Tone Reproduction for Digital Images", Eq. 3
        return x / (1.0 + luminance(x));
    }

    vec3 Tonemap_Unreal(const vec3 x) {
        // Unreal, Documentation: "Color Grading"
        // Adapted to be close to Tonemap_ACES, with similar range
        // Gamma 2.2 correction is baked in, don't use with sRGB conversion!
        return x / (x + 0.155) * 1.019;
    }

    vec3 Tonemap_FilmicALU(const vec3 x) {
        // Hable 2010, "Filmic Tonemapping Operators"
        // Based on Duiker's curve, optimized by Hejl and Burgess-Dawson
        // Gamma 2.2 correction is baked in, don't use with sRGB conversion!
        vec3 c = max(vec3(0.0), x - 0.004);
        return (c * (c * 6.2 + 0.5)) / (c * (c * 6.2 + 1.7) + 0.06);
    }

    vec3 Tonemap_ACES(const vec3 x) {
        // Narkowicz 2015, "ACES Filmic Tone Mapping Curve"
        const float a = 2.51;
        const float b = 0.03;
        const float c = 2.43;
        const float d = 0.59;
        const float e = 0.14;
        return (x * (a * x + b)) / (x * (c * x + d) + e);
    }

    //------------------------------------------------------------------------------
    // Tone-mapping operators for HDR output
    //------------------------------------------------------------------------------

#if TONE_MAPPING_OPERATOR == TONE_MAPPING_ACES_REC2020_1K
    vec3 Tonemap_ACES_Rec2020_1k(const vec3 x) {
        // Narkowicz 2016, "HDR Display â€“ First Steps"
        const float a = 15.8;
        const float b = 2.12;
        const float c = 1.2;
        const float d = 5.92;
        const float e = 1.9;
        return (x * (a * x + b)) / (x * (c * x + d) + e);
    }
#endif

    //------------------------------------------------------------------------------
    // Debug tone-mapping operators, for LDR output
    //------------------------------------------------------------------------------

    /**
     * Converts the input HDR RGB color into one of 16 debug colors that represent
     * the pixel's exposure. When the output is cyan, the input color represents
     * middle gray (18% exposure). Every exposure stop above or below middle gray
     * causes a color shift.
     *
     * The relationship between exposures and colors is:
     *
     * -5EV  - black
     * -4EV  - darkest blue
     * -3EV  - darker blue
     * -2EV  - dark blue
     * -1EV  - blue
     *  OEV  - cyan
     * +1EV  - dark green
     * +2EV  - green
     * +3EV  - yellow
     * +4EV  - yellow-orange
     * +5EV  - orange
     * +6EV  - bright red
     * +7EV  - red
     * +8EV  - magenta
     * +9EV  - purple
     * +10EV - white
     */
#if TONE_MAPPING_OPERATOR == TONE_MAPPING_DISPLAY_RANGE
    vec3 Tonemap_DisplayRange(const vec3 x) {
        // 16 debug colors + 1 duplicated at the end for easy indexing
        const vec3 debugColors[17] = vec3[](
             vec3(0.0, 0.0, 0.0),         // black
             vec3(0.0, 0.0, 0.1647),      // darkest blue
             vec3(0.0, 0.0, 0.3647),      // darker blue
             vec3(0.0, 0.0, 0.6647),      // dark blue
             vec3(0.0, 0.0, 0.9647),      // blue
             vec3(0.0, 0.9255, 0.9255),   // cyan
             vec3(0.0, 0.5647, 0.0),      // dark green
             vec3(0.0, 0.7843, 0.0),      // green
             vec3(1.0, 1.0, 0.0),         // yellow
             vec3(0.90588, 0.75294, 0.0), // yellow-orange
             vec3(1.0, 0.5647, 0.0),      // orange
             vec3(1.0, 0.0, 0.0),         // bright red
             vec3(0.8392, 0.0, 0.0),      // red
             vec3(1.0, 0.0, 1.0),         // magenta
             vec3(0.6, 0.3333, 0.7882),   // purple
             vec3(1.0, 1.0, 1.0),         // white
             vec3(1.0, 1.0, 1.0)          // white
        );

        // The 5th color in the array (cyan) represents middle gray (18%)
        // Every stop above or below middle gray causes a color shift
        float v = log2(luminance(x) / 0.18);
        v = clamp(v + 5.0, 0.0, 15.0);
        int index = int(v);
        return mix(debugColors[index], debugColors[index + 1], v - float(index));
    }
#endif

    //------------------------------------------------------------------------------
    // Tone-mapping dispatch
    //------------------------------------------------------------------------------

    /**
     * Tone-maps the specified RGB color. The input color must be in linear HDR and
     * pre-exposed. Our HDR to LDR tone mapping operators are designed to tone-map
     * the range [0..~8] to [0..1].
     */
    vec3 tonemap(const vec3 x) {
#if TONE_MAPPING_OPERATOR == TONE_MAPPING_UNREAL
        return Tonemap_Unreal(x);
#elif TONE_MAPPING_OPERATOR == TONE_MAPPING_FILMIC_ALU
        return Tonemap_FilmicALU(x);
#elif TONE_MAPPING_OPERATOR == TONE_MAPPING_LINEAR
        return Tonemap_Linear(x);
#elif TONE_MAPPING_OPERATOR == TONE_MAPPING_REINHARD
        return Tonemap_Reinhard(x);
#elif TONE_MAPPING_OPERATOR == TONE_MAPPING_ACES
        return Tonemap_ACES(x);
#elif TONE_MAPPING_OPERATOR == TONE_MAPPING_ACES_REC2020_1K
        return Tonemap_ACES_Rec2020_1k(x);
#elif TONE_MAPPING_OPERATOR == TONE_MAPPING_DISPLAY_RANGE
        return Tonemap_DisplayRange(x);
#endif
    }

    //------------------------------------------------------------------------------
    // Processing tone-mappers
    //------------------------------------------------------------------------------

    vec3 Tonemap_ReinhardWeighted(const vec3 x, float weight) {
        // Weighted Reinhard tone-mapping operator designed for post-processing
        // This tone-mapping operator is invertible
        return x * (weight / (max3(x) + 1.0));
    }

    vec3 Tonemap_ReinhardWeighted_Invert(const vec3 x) {
        // Inverse Reinhard tone-mapping operator, designed to be used in conjunction
        // with the weighted Reinhard tone-mapping operator
        return x / (1.0 - max3(x));
    }

    //------------------------------------------------------------------------------
    // Conversion functions configuration
    //------------------------------------------------------------------------------

    // Defines the set of opto-electronic and electro-optical conversion functions
#define CONVERSION_FUNCTION_LINEAR     0
#define CONVERSION_FUNCTION_sRGB       1
#define CONVERSION_FUNCTION_sRGB_FAST  2

#if TONE_MAPPING_OPERATOR <= TONE_MAPPING_FILMIC_ALU
        #define CONVERSION_FUNCTION        CONVERSION_FUNCTION_LINEAR
#else
        #ifdef TARGET_MOBILE
        #define CONVERSION_FUNCTION        CONVERSION_FUNCTION_sRGB_FAST
        #else
        #define CONVERSION_FUNCTION        CONVERSION_FUNCTION_sRGB
        #endif
#endif

    //------------------------------------------------------------------------------
    // Opto-electronic conversion functions (linear to non-linear)
    //------------------------------------------------------------------------------

    float OECF_sRGB(const float linear) {
        // IEC 61966-2-1:1999
        float sRGBLow  = linear * 12.92;
        float sRGBHigh = (pow(linear, 1.0 / 2.4) * 1.055) - 0.055;
        return linear <= 0.0031308 ? sRGBLow : sRGBHigh;
    }

    vec3 OECF_sRGB(const vec3 linear) {
        return vec3(OECF_sRGB(linear.r), OECF_sRGB(linear.g), OECF_sRGB(linear.b));
    }

    vec3 OECF_sRGBFast(const vec3 linear) {
        return pow(linear, vec3(1.0 / 2.2));
    }

    //------------------------------------------------------------------------------
    // Conversion functions
    //------------------------------------------------------------------------------

    /**
     * Applies the opto-electronic conversion function to the specified LDR RGB
     * linear color and outputs an LDR RGB non-linear color in sRGB space.
     */
    vec3 OECF(const vec3 linear) {
#if CONVERSION_FUNCTION == CONVERSION_FUNCTION_LINEAR
        return linear;
#elif CONVERSION_FUNCTION == CONVERSION_FUNCTION_sRGB
        return OECF_sRGB(linear);
#elif CONVERSION_FUNCTION == CONVERSION_FUNCTION_sRGB_FAST
        return OECF_sRGBFast(linear);
#endif
    }


    //------------------------------------------------------------------------------
    // Dithering configuration
    //------------------------------------------------------------------------------

    // Dithering operators
    #define DITHERING_NONE                 0
    #define DITHERING_INTERLEAVED_NOISE    1
    #define DITHERING_VLACHOS              2
    #define DITHERING_TRIANGLE_NOISE       3
    #define DITHERING_TRIANGLE_NOISE_RGB   4

#ifdef TARGET_MOBILE
    #define DITHERING_OPERATOR         DITHERING_INTERLEAVED_NOISE
#else
    #define DITHERING_OPERATOR         DITHERING_VLACHOS
#endif

    //------------------------------------------------------------------------------
    // Noise
    //------------------------------------------------------------------------------

    float triangleNoise(highp vec2 n) {
        // triangle noise, in [-1.0..1.0[ range
        n += vec2(0.07 * fract(postProcessUniforms.time));
        n  = fract(n * vec2(5.3987, 5.4421));
        n += dot(n.yx, n.xy + vec2(21.5351, 14.3137));

        highp float xy = n.x * n.y;
        // compute in [0..2[ and remap to [-1.0..1.0[
        return fract(xy * 95.4307) + fract(xy * 75.04961) - 1.0;
    }

    float interleavedGradientNoise(const highp vec2 n) {
        return fract(52.982919 * fract(dot(vec2(0.06711, 0.00584), n)));
    }

    //------------------------------------------------------------------------------
    // Dithering
    //------------------------------------------------------------------------------

    vec4 Dither_InterleavedGradientNoise(vec4 rgba) {
        // Jimenez 2014, "Next Generation Post-Processing in Call of Duty"
        float noise = interleavedGradientNoise(gl_FragCoord.xy + postProcessUniforms.time);
        // remap from [0..1[ to [-1..1[
        noise = (noise * 2.0) - 1.0;
        return vec4(rgba.rgb + noise / 255.0, rgba.a);
    }

    vec4 Dither_Vlachos(vec4 rgba) {
        // Vlachos 2016, "Advanced VR Rendering"
        highp vec3 noise = vec3(dot(vec2(171.0, 231.0), gl_FragCoord.xy + postProcessUniforms.time));
        noise = fract(noise / vec3(103.0, 71.0, 97.0));
        // remap from [0..1[ to [-1..1[
        noise = (noise * 2.0) - 1.0;
        return vec4(rgba.rgb + (noise / 255.0), rgba.a);
    }

    vec4 Dither_TriangleNoise(vec4 rgba) {
        // GjÃ¸l 2016, "Banding in Games: A Noisy Rant"
        return rgba + triangleNoise(gl_FragCoord.xy * frameUniforms.resolution.zw) / 255.0;
    }

    vec4 Dither_TriangleNoiseRGB(vec4 rgba) {
        // GjÃ¸l 2016, "Banding in Games: A Noisy Rant"
        vec2 uv = gl_FragCoord.xy * frameUniforms.resolution.zw;
        vec3 dither = vec3(
                triangleNoise(uv),
                triangleNoise(uv + 0.1337),
                triangleNoise(uv + 0.3141)) / 255.0;
        return vec4(rgba.rgb + dither, rgba.a + dither.x);
    }

    //------------------------------------------------------------------------------
    // Dithering dispatch
    //------------------------------------------------------------------------------

    /**
     * Dithers the specified RGB color based on the current time and fragment
     * coordinates the input must be in the final color space (including OECF).
     * This dithering function assumes we are dithering to an 8-bit target.
     * This function dithers the alpha channel assuming premultiplied output
     */
    vec4 dither(vec4 rgba) {
#if DITHERING_OPERATOR == DITHERING_NONE
        return rgba;
#elif DITHERING_OPERATOR == DITHERING_INTERLEAVED_NOISE
        return Dither_InterleavedGradientNoise(rgba);
#elif DITHERING_OPERATOR == DITHERING_VLACHOS
        return Dither_Vlachos(rgba);
#elif DITHERING_OPERATOR  == DITHERING_TRIANGLE_NOISE
        return Dither_TriangleNoise(rgba);
#elif DITHERING_OPERATOR  == DITHERING_TRIANGLE_NOISE_RGB
        return Dither_TriangleNoiseRGB(rgba);
#endif
    }

    vec3 resolveFragment(const ivec2 uv) {
        return texelFetch(materialParams_colorBuffer, uv, 0).rgb;
    }

    vec4 resolveAlphaFragment(const ivec2 uv) {
        return texelFetch(materialParams_colorBuffer, uv, 0);
    }

    vec4 resolve() {
#if POST_PROCESS_OPAQUE
        vec4 color = vec4(resolveFragment(ivec2(getUV())), 1.0);
        color.rgb  = tonemap(color.rgb);
        color.rgb  = OECF(color.rgb);
        color.a    = luminance(color.rgb);
#else
        vec4 color = resolveAlphaFragment(ivec2(getUV()));
        color.rgb /= color.a + FLT_EPS;
        color.rgb  = tonemap(color.rgb);
        color.rgb  = OECF(color.rgb);
        color.rgb *= color.a + FLT_EPS;
#endif
        return color;
    }

    void postProcess(inout PostProcessInputs postProcess) {
        postProcess.color = resolve();
        if (materialParams.dithering > 0) {
            postProcess.color = dither(postProcess.color);
        }
    }

}
