material {
    name : bilateralBlur,
    parameters : [
        {
            type : sampler2d,
            name : ssao,
            precision: medium
        },
        {
            type : sampler2d,
            name : depth,
            precision: high
        },
        {
            type : float2,
            name : axis,
            precision: high
        },
        {
            type : float,
            name : oneOverEdgeDistance
        }
    ],
    variables : [
        vertex
    ],
    domain : postprocess,
    depthWrite : false,
    depthCulling : true
}

vertex {
    void postProcessVertex(inout PostProcessVertexInputs postProcess) {
        postProcess.vertex.xy = postProcess.normalizedUV;
    }
}

fragment {
    const int kGaussianCount = 4;
    const float kGaussianSamples[] = float[](
        0.199471, 0.176033, 0.120985, 0.064759      // stdev = 2.0
    );

    highp float linearizeDepth(highp float depth) {
        // Our far plane is at infinity, which causes a division by zero below, which in turn
        // causes some issues on some GPU. We workaround it by replacing "infinity" by the closest
        // value representable in  a 24 bit depth buffer.
        const float preventDiv0 = -1.0 / 16777216.0;
        highp mat4 projection = getClipFromViewMatrix();
        highp float z = depth * 2.0 - 1.0; // depth in clip space
        return -projection[3].z / min(preventDiv0, z + projection[2].z);
    }

    float bilateralWeight(const vec2 p, in float depth) {
        float sampleDepth = textureLod(materialParams_depth, p, 0.0).r;
        float ddepth = linearizeDepth(sampleDepth) - depth;
        float diff = materialParams.oneOverEdgeDistance * ddepth;
        return max(0.0, 1.0 - diff * diff);
    }

    void tap(inout float sum, inout float totalWeight, float weight, float depth, vec2 position) {
        // ambient occlusion sample
        float ao = textureLod(materialParams_ssao, position, 0.0).r;
        // bilateral sample
        float bilateral = bilateralWeight(position, depth);
        bilateral *= weight;
        sum += ao * bilateral;
        totalWeight += bilateral;
    }

    void postProcess(inout PostProcessInputs postProcess) {
        highp vec2 uv = variable_vertex.xy; // interpolated at pixel's center

        float depth = textureLod(materialParams_depth, uv, 0.0).r;
        depth = linearizeDepth(depth);

        // we handle the center pixel separately because it doesn't participate in
        // bilateral filtering
        float totalWeight = kGaussianSamples[0];
        float sum = textureLod(materialParams_ssao, uv, 0.0).r * totalWeight;

        vec2 offset = materialParams.axis;
        for (int i = 1; i < kGaussianCount; i++) {
            float weight = kGaussianSamples[i];
            tap(sum, totalWeight, weight, depth, uv + offset);
            tap(sum, totalWeight, weight, depth, uv - offset);
            offset += materialParams.axis;
        }

        postProcess.color.r = sum * (1.0 / totalWeight);
    }
}
