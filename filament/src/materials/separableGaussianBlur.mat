material {
    name : separableGaussianBlur,
    parameters : [
        {
            type : sampler2d,
            name : source,
            precision: medium
        },
        {
            type : float4,
            name : resolution,
            precision: high
        },
        {
            type : float2,
            name : axis
        },
        {
            type : float,
            name : level
        },
        {
            type : int,
            name : count
        },
        {
            type : float2[32],
            name : kernel
        }
    ],
    variables : [
        vertex
    ],
    domain : postprocess,
    depthWrite : false,
    depthCulling : false
}

vertex {
    void postProcessVertex(inout PostProcessVertexInputs postProcess) {
        // in the fragment shader, this is interpolated to pixel centers, but since we use
        // texel-fetch, it's not what we want. Convert from screen uv to texture uv.
        vec2 size = vec2(textureSize(materialParams_source, int(materialParams.level)));
        postProcess.vertex.xy = (postProcess.normalizedUV - 0.5 * materialParams.resolution.zw) + 0.5 / size;
    }
}

fragment {
    void tap(inout vec3 sum, float weight, highp vec2 position) {
        sum += weight * textureLod(materialParams_source, position, materialParams.level).rgb;
    }

    void postProcess(inout PostProcessInputs postProcess) {
        highp vec2 uv = variable_vertex.xy;

        // we handle the center pixel separately
        vec3 sum = vec3(0);
        tap(sum, materialParams.kernel[0].x, uv);

        vec2 offset = materialParams.axis;
        for (int i = 1; i < materialParams.count; i++, offset += materialParams.axis * 2.0) {
            float k = materialParams.kernel[i].x;
            vec2 o = offset + materialParams.axis * materialParams.kernel[i].y;
            tap(sum, k, uv + o);
            tap(sum, k, uv - o);
        }

        postProcess.color.rgb = sum;
    }
}
