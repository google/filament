//* Copyright 2019 The Dawn & Tint Authors
//*
//* Redistribution and use in source and binary forms, with or without
//* modification, are permitted provided that the following conditions are met:
//*
//* 1. Redistributions of source code must retain the above copyright notice, this
//*    list of conditions and the following disclaimer.
//*
//* 2. Redistributions in binary form must reproduce the above copyright notice,
//*    this list of conditions and the following disclaimer in the documentation
//*    and/or other materials provided with the distribution.
//*
//* 3. Neither the name of the copyright holder nor the names of its
//*    contributors may be used to endorse or promote products derived from
//*    this software without specific prior written permission.
//*
//* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include <algorithm>
#include <cstring>
#include <string_view>
#include <type_traits>
#include <vector>
#include <utility>

#include "dawn/wire/client/Client.h"
#include "dawn/wire/client/webgpu.h"

namespace dawn::wire::client {

    // Template function for constexpr branching when creating new objects.
    template <typename Parent, typename Child, typename... Args>
    Child* Create(Parent p, Args... args) {
        if constexpr (std::is_constructible_v<Child, const ObjectBaseParams&, decltype(args)...>) {
            return p->GetClient()->template Make<Child>(args...).Detach();
        } else if constexpr (std::is_constructible_v<Child, const ObjectBaseParams&, const ObjectHandle&, decltype(args)...>) {
            return p->GetClient()->template Make<Child>(p->GetEventManagerHandle(), args...).Detach();
        } else {
            if constexpr (std::is_base_of_v<ObjectWithEventsBase, Child>) {
                return p->GetClient()->template Make<Child>(p->GetEventManagerHandle()).Detach();
            } else {
                return p->GetClient()->template Make<Child>().Detach();
            }
        }
    }

}  // namespace dawn::wire::client

//* Implementation of the client API functions.
{% for type in by_category["object"] %}
    {%- set Type = "dawn::wire::client::" + type.name.CamelCase() -%}
    {%- set cType = as_cType(type.name) -%}

    {% for method in type.methods %}
        {% set Suffix = as_MethodSuffix(type.name, method.name) %}

        DAWN_WIRE_EXPORT {{as_cType(method.return_type.name)}} {{as_cMethodNamespaced(type.name, method.name, Name('dawn wire client'))}}(
            {{-cType}} cSelf
            {%- for arg in method.arguments -%}
                , {{as_annotated_cType(arg)}}
            {%- endfor -%}
        ) {
            auto self = reinterpret_cast<dawn::wire::client::{{as_wireType(type)}}>(cSelf);
            {% if Suffix not in client_handwritten_commands %}
                dawn::wire::{{Suffix}}Cmd cmd;

                //* Create the structure going on the wire on the stack and fill it with the value
                //* arguments so it can compute its size.
                cmd.self = cSelf;

                //* For object creation, store the object ID the client will use for the result.
                {% if method.return_type.category == "object" %}
                    {% set ReturnObj = "dawn::wire::client::" + method.return_type.name.CamelCase() %}
                    {{ReturnObj}}* returnObject = dawn::wire::client::Create<dawn::wire::client::{{as_wireType(type)}}, {{ReturnObj}}>(self
                        {%- for arg in method.arguments -%}
                                , {{as_varName(arg.name)}}
                        {%- endfor -%}
                    );
                    cmd.result = returnObject->GetWireHandle();
                {% endif %}

                {% for arg in method.arguments %}
                    //* Commands with mutable pointers should not be autogenerated.
                    {{assert(arg.annotation != "*")}}
                    cmd.{{as_varName(arg.name)}} = {{as_varName(arg.name)}};
                {% endfor %}

                //* Allocate space to send the command and copy the value args over.
                self->GetClient()->SerializeCommand(cmd);

                {% if method.return_type.category == "object" %}
                    return ToAPI(returnObject);
                {% endif %}
            {% else %}
                return self->{{method.name.CamelCase()}}(
                    {%- for arg in method.arguments -%}
                        {%if not loop.first %}, {% endif %} {{as_varName(arg.name)}}
                    {%- endfor -%});
            {% endif %}
        }
    {% endfor %}

    //* When an object's refcount reaches 0, notify the server side of it and delete it.
    DAWN_WIRE_EXPORT void {{as_cMethodNamespaced(type.name, Name("release"), Name('dawn wire client'))}}({{cType}} cObj) {
        {{Type}}* obj = reinterpret_cast<{{Type}}*>(cObj);
        obj->APIRelease();
    }

    DAWN_WIRE_EXPORT void {{as_cMethodNamespaced(type.name, Name("add ref"), Name('dawn wire client'))}}({{cType}} cObj) {
        reinterpret_cast<{{Type}}*>(cObj)->APIAddRef();
    }

{% endfor %}

namespace {
    struct ProcEntry {
        WGPUProc proc;
        std::string_view name;
    };
    static const ProcEntry sProcMap[] = {
        {% for (type, method) in c_methods_sorted_by_name %}
            { reinterpret_cast<WGPUProc>({{as_cMethodNamespaced(type.name, method.name, Name('dawn wire client'))}}), "{{as_cMethod(type.name, method.name)}}" },
        {% endfor %}
    };
    static constexpr size_t sProcMapSize = sizeof(sProcMap) / sizeof(sProcMap[0]);
}  // anonymous namespace

DAWN_WIRE_EXPORT WGPUProc {{as_cMethodNamespaced(None, Name('get proc address'), Name('dawn wire client'))}}(WGPUStringView cProcName) {
    if (cProcName.data == nullptr) {
        return nullptr;
    }

    std::string_view procName(cProcName.data, cProcName.length != WGPU_STRLEN ? cProcName.length : strlen(cProcName.data));

    const ProcEntry* entry = std::lower_bound(&sProcMap[0], &sProcMap[sProcMapSize], procName,
        [](const ProcEntry &a, const std::string_view& b) -> bool {
            return a.name.compare(b) < 0;
        }
    );

    if (entry != &sProcMap[sProcMapSize] && entry->name == procName) {
        return entry->proc;
    }

    // Special case the free-standing functions of the API.
    // TODO(dawn:1238) Checking string one by one is slow, it needs to be optimized.
    {% for function in by_category["function"] %}
        if (procName == "{{as_cMethod(None, function.name)}}") {
            return reinterpret_cast<WGPUProc>({{as_cMethodNamespaced(None, function.name, Name('dawn wire client'))}});
        }

    {% endfor %}
    return nullptr;
}

namespace dawn::wire::client {

    std::vector<std::string_view> GetProcMapNamesForTesting() {
        std::vector<std::string_view> result;
        result.reserve(sProcMapSize);
        for (const ProcEntry& entry : sProcMap) {
            result.push_back(entry.name);
        }
        return result;
    }

    {% set Prefix = metadata.proc_table_prefix %}

    constexpr {{Prefix}}ProcTable MakeProcTable() {
        {{Prefix}}ProcTable procs = {};
        {% for function in by_category["function"] %}
            procs.{{as_varName(function.name)}} = {{as_cMethodNamespaced(None, function.name, Name('dawn wire client'))}};
        {% endfor %}
        {% for type in by_category["object"] %}
            {% for method in c_methods(type) %}
                procs.{{as_varName(type.name, method.name)}} = {{as_cMethodNamespaced(type.name, method.name, Name('dawn wire client'))}};
            {% endfor %}
        {% endfor %}
        return procs;
    }

    static {{Prefix}}ProcTable gProcTable = MakeProcTable();

    const {{Prefix}}ProcTable& GetProcs() {
        return gProcTable;
    }

}  // namespace dawn::wire::client
