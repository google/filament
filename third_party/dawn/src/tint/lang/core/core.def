// Copyright 2021 The Dawn & Tint Authors
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

////////////////////////////////////////////////////////////////////////////////
// core builtin definition file                                               //
//                                                                            //
// This file is used to generate parts of the Tint BuiltinTable, various      //
// enum definition files.                                                     //
//                                                                            //
// After modifying this file, run:                                            //
//    tools/run gen                                                           //
// from the Dawn source directory.                                            //
//                                                                            //
// See docs/tint/intrinsic_definition_files.md for syntax                     //
////////////////////////////////////////////////////////////////////////////////

import "src/tint/lang/core/address_space.def"
import "src/tint/lang/core/access.def"
import "src/tint/lang/core/subgroup_matrix_kind.def"
import "src/tint/lang/core/texel_format.def"

////////////////////////////////////////////////////////////////////////////////
// Enumerators                                                                //
////////////////////////////////////////////////////////////////////////////////

// https://www.w3.org/TR/WGSL/#builtin-inputs-outputs
enum builtin_value {
  position
  vertex_index
  instance_index
  front_facing
  frag_depth
  local_invocation_id
  local_invocation_index
  global_invocation_id
  workgroup_id
  num_workgroups
  sample_index
  sample_mask
  clip_distances
  subgroup_invocation_id
  subgroup_size
  @internal __point_size
  @internal __cull_distance

}

// https://www.w3.org/TR/WGSL/#interpolation
enum interpolation_type {
  perspective
  linear
  flat
}

// https://www.w3.org/TR/WGSL/#interpolation
enum interpolation_sampling {
  center
  centroid
  sample
  first
  either
}

enum builtin_type {
  // https://www.w3.org/TR/WGSL/#scalar-types
  bool
  f16
  f32
  i32
  u32
  // https://www.w3.org/TR/WGSL/#matrix-types
  mat2x2
  mat2x3
  mat2x4
  mat3x2
  mat3x3
  mat3x4
  mat4x2
  mat4x3
  mat4x4
  mat2x2f
  mat2x2h
  mat2x3f
  mat2x3h
  mat2x4f
  mat2x4h
  mat3x2f
  mat3x2h
  mat3x3f
  mat3x3h
  mat3x4f
  mat3x4h
  mat4x2f
  mat4x2h
  mat4x3f
  mat4x3h
  mat4x4f
  mat4x4h
  // https://www.w3.org/TR/WGSL/#vector-types
  vec2
  vec3
  vec4
  vec2f
  vec2h
  vec2i
  vec2u
  vec3f
  vec3h
  vec3i
  vec3u
  vec4f
  vec4h
  vec4i
  vec4u
  // https://www.w3.org/TR/WGSL/#array-types
  array
  // https://www.w3.org/TR/WGSL/#atomic-types
  atomic
  // https://www.w3.org/TR/WGSL/#ref-ptr-types
  ptr
  // https://www.w3.org/TR/WGSL/#sampler-type
  sampler
  sampler_comparison
  // https://www.w3.org/TR/WGSL/#texture-depth
  texture_depth_2d
  texture_depth_2d_array
  texture_depth_cube
  texture_depth_cube_array
  texture_depth_multisampled_2d
  // https://www.w3.org/TR/WGSL/#sampled-texture-type
  texture_1d
  texture_2d
  texture_2d_array
  texture_3d
  texture_cube
  texture_cube_array
  // https://www.w3.org/TR/WGSL/#multisampled-texture-type
  texture_multisampled_2d
  // https://www.w3.org/TR/WGSL/#texture-storage
  texture_storage_1d
  texture_storage_2d
  texture_storage_2d_array
  texture_storage_3d
  // https://www.w3.org/TR/WGSL/#external-texture-type
  texture_external
  // chromium_internal_input_attachments
  input_attachment
  // chromium_experimental_subgroup_matrix
  subgroup_matrix_left
  subgroup_matrix_right
  subgroup_matrix_result
  // sized_binding_array
  binding_array

  // Internal types.
  __atomic_compare_exchange_result_i32
  __atomic_compare_exchange_result_u32
  __frexp_result_abstract
  __frexp_result_f16
  __frexp_result_f32
  __frexp_result_vec2_abstract
  __frexp_result_vec2_f16
  __frexp_result_vec2_f32
  __frexp_result_vec3_abstract
  __frexp_result_vec3_f16
  __frexp_result_vec3_f32
  __frexp_result_vec4_abstract
  __frexp_result_vec4_f16
  __frexp_result_vec4_f32
  __modf_result_abstract
  __modf_result_f16
  __modf_result_f32
  __modf_result_vec2_abstract
  __modf_result_vec2_f16
  __modf_result_vec2_f32
  __modf_result_vec3_abstract
  __modf_result_vec3_f16
  __modf_result_vec3_f32
  __modf_result_vec4_abstract
  __modf_result_vec4_f16
  __modf_result_vec4_f32
}

// https://gpuweb.github.io/gpuweb/wgsl/#attributes
// Notes:
//  * `diagnostic` is listed, even though it is a keyword, so it appears in suggested alternatives
//  * `const` is not listed here as it can not be written in user programs and should not show up
//     in error messages
enum attribute {
  align
  binding
  blend_src
  builtin
  compute
  diagnostic
  fragment
  group
  id
  interpolate
  invariant
  location
  must_use
  size
  vertex
  workgroup_size

  // framebuffer-fetch input
  color

  // chromium_internal_input_attachments
  input_attachment_index
}

// These are parameter usages which show up in other def files but not in core.def.
enum usages {
  base
  bits
  coords
  count
  depth
  dref
  compare_value
  elements
  exp
  height
  i
  image_operands
  insert
  level
  location
  num_levels
  original_value
  refz
  samples
  result
  width
  x
}

////////////////////////////////////////////////////////////////////////////////
// Primitive types                                                            //
////////////////////////////////////////////////////////////////////////////////

// https://gpuweb.github.io/gpuweb/wgsl/#plain-types-section
type bool
type i8
type u8
@precedence(3) type i32
@precedence(2) type u32
@precedence(1) type f32
@precedence(0) type f16
type vec2<T>
type vec3<T>
type vec4<T>
type mat2x2<T>
type mat2x3<T>
type mat2x4<T>
type mat3x2<T>
type mat3x3<T>
type mat3x4<T>
type mat4x2<T>
type mat4x3<T>
type mat4x4<T>
@display("vec{N}<{T}>")     type vec<N: num, T>
@display("mat{N}x{M}<{T}>") type mat<N: num, M: num, T>
type ptr<S: address_space, T, A: access>
type atomic<T>
@display("array<{T}>") type runtime_array<T>
type array<T, N: num>
type binding_array<T, N: num>
type sampler
type sampler_comparison
type texture_1d<T>
type texture_2d<T>
type texture_2d_array<T>
type texture_3d<T>
type texture_cube<T>
type texture_cube_array<T>
type texture_multisampled_2d<T>
type texture_depth_2d
type texture_depth_2d_array
type texture_depth_cube
type texture_depth_cube_array
type texture_depth_multisampled_2d
type texture_storage_1d<F: texel_format, A: access>
type texture_storage_2d<F: texel_format, A: access>
type texture_storage_2d_array<F: texel_format, A: access>
type texture_storage_3d<F: texel_format, A: access>
type texture_external
type input_attachment<T>

@display("__modf_result_{T}")        type __modf_result<T>
@display("__modf_result_vec{N}_{T}") type __modf_result_vec<N: num, T>
@display("__frexp_result_{T}")        type __frexp_result<T>
@display("__frexp_result_vec{N}_{T}") type __frexp_result_vec<N: num, T>

type __atomic_compare_exchange_result<T>

type subgroup_matrix<S: subgroup_matrix_kind, T, C: num, R: num>

////////////////////////////////////////////////////////////////////////////////
// Type matchers                                                              //
//                                                                            //
// A type matcher that can match one or more types.                           //
////////////////////////////////////////////////////////////////////////////////

match scalar: f32 | f16 | i32 | u32 | bool
match scalar_no_f32: i32 | f16 | u32 | bool
match scalar_no_f16: f32 | i32 | u32 | bool
match scalar_no_i32: f32 | f16 | u32 | bool
match scalar_no_u32: f32 | f16 | i32 | bool
match scalar_no_bool: f32 | f16 | i32 | u32
match fiu32_f16: f32 | i32 | u32 | f16
match fiu32: f32 | i32 | u32
match fi32_f16: f32 | i32 | f16
match fi32: f32 | i32
match f32_f16: f32 | f16
match iu32: i32 | u32

match subgroup_matrix_elements: f32 | f16 | u32 | i32
match subgroup_matrix_kind_left : subgroup_matrix_kind.left
match subgroup_matrix_kind_right : subgroup_matrix_kind.right
match subgroup_matrix_kind_result : subgroup_matrix_kind.result

////////////////////////////////////////////////////////////////////////////////
// Enum matchers                                                              //
//                                                                            //
// A number matcher that can match one or more enumerator values.             //
// All enumerator values listed in the match declaration need to be from the  //
// same enum.                                                                 //
////////////////////////////////////////////////////////////////////////////////

// https://gpuweb.github.io/gpuweb/wgsl/#texel-formats
match f32_texel_format
  : texel_format.r8unorm
  | texel_format.bgra8unorm
  | texel_format.rgba8unorm
  | texel_format.rgba8snorm
  | texel_format.rgba16float
  | texel_format.r32float
  | texel_format.rg32float
  | texel_format.rgba32float
match i32_texel_format
  : texel_format.rgba8sint
  | texel_format.rgba16sint
  | texel_format.r32sint
  | texel_format.rg32sint
  | texel_format.rgba32sint
match u32_texel_format
  : texel_format.rgba8uint
  | texel_format.rgba16uint
  | texel_format.r32uint
  | texel_format.rg32uint
  | texel_format.rgba32uint

match write: access.write
match read_write: access.read_write
match readable
  : access.read
  | access.read_write
match writable
  : access.write
  | access.read_write

match function_private_workgroup
  : address_space.function
  | address_space.private
  | address_space.workgroup
match workgroup_or_storage
  : address_space.workgroup
  | address_space.storage
match storage
  : address_space.storage
match workgroup
  : address_space.workgroup

////////////////////////////////////////////////////////////////////////////////
// Builtin Functions                                                          //
////////////////////////////////////////////////////////////////////////////////

// https://gpuweb.github.io/gpuweb/wgsl/#builtin-functions
@must_use @const implicit(T: fiu32_f16) fn abs(T) -> T
@must_use @const implicit(N: num, T: fiu32_f16) fn abs(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn acos(@test_value(0.96891242171) T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn acos(@test_value(0.96891242171) vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn acosh(@test_value(1.5430806348) T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn acosh(@test_value(1.5430806348) vec<N, T>) -> vec<N, T>
@must_use @const fn all(bool) -> bool
@must_use @const implicit(N: num) fn all(vec<N, bool>) -> bool
@must_use @const fn any(bool) -> bool
@must_use @const implicit(N: num) fn any(vec<N, bool>) -> bool
@must_use implicit(T, A: access) fn arrayLength(ptr<storage, runtime_array<T>, A>) -> u32
@must_use @const implicit(T: f32_f16) fn asin(@test_value(0.479425538604) T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn asin(@test_value(0.479425538604) vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn asinh(T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn asinh(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn atan(T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn atan(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn atan2(T, T) -> T
@must_use @const implicit(T: f32_f16, N: num) fn atan2(vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn atanh(@test_value(0.5) T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn atanh(@test_value(0.5) vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn ceil(@test_value(1.5) T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn ceil(@test_value(1.5) vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: fiu32_f16) fn clamp(T, T, T) -> T
@must_use @const implicit(T: fiu32_f16, N: num) fn clamp(vec<N, T>, vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn cos(@test_value(0) T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn cos(@test_value(0) vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn cosh(@test_value(0) T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn cosh(@test_value(0) vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: iu32) fn countLeadingZeros(T) -> T
@must_use @const implicit(N: num, T: iu32) fn countLeadingZeros(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: iu32) fn countOneBits(T) -> T
@must_use @const implicit(N: num, T: iu32) fn countOneBits(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: iu32) fn countTrailingZeros(T) -> T
@must_use @const implicit(N: num, T: iu32) fn countTrailingZeros(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn cross(vec3<T>, vec3<T>) -> vec3<T>
@must_use @const implicit(T: f32_f16) fn degrees(T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn degrees(vec<N, T>) -> vec<N, T>
@must_use @const implicit(N: num, T: f32_f16) fn determinant(mat<N, N, T>) -> T
@must_use @const implicit(T: f32_f16) fn distance(T, T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn distance(vec<N, T>, vec<N, T>) -> T
@must_use @const implicit(N: num, T: fiu32_f16) fn dot(vec<N, T>, vec<N, T>) -> T
@must_use @const fn dot4I8Packed(u32, u32) -> i32
@must_use @const fn dot4U8Packed(u32, u32) -> u32
@must_use @stage("fragment") fn dpdx(f32) -> f32
@must_use @stage("fragment") implicit(N: num) fn dpdx(vec<N, f32>) -> vec<N, f32>
@must_use @stage("fragment") fn dpdxCoarse(f32) -> f32
@must_use @stage("fragment") implicit(N: num) fn dpdxCoarse(vec<N, f32>) -> vec<N, f32>
@must_use @stage("fragment") fn dpdxFine(f32) -> f32
@must_use @stage("fragment") implicit(N: num) fn dpdxFine(vec<N, f32>) -> vec<N, f32>
@must_use @stage("fragment") fn dpdy(f32) -> f32
@must_use @stage("fragment") implicit(N: num) fn dpdy(vec<N, f32>) -> vec<N, f32>
@must_use @stage("fragment") fn dpdyCoarse(f32) -> f32
@must_use @stage("fragment") implicit(N: num) fn dpdyCoarse(vec<N, f32>) -> vec<N, f32>
@must_use @stage("fragment") fn dpdyFine(f32) -> f32
@must_use @stage("fragment") implicit(N: num) fn dpdyFine(vec<N, f32>) -> vec<N, f32>
@must_use @const implicit(T: f32_f16) fn exp(T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn exp(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn exp2(T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn exp2(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: iu32) fn extractBits(T, u32, u32) -> T
@must_use @const implicit(N: num, T: iu32) fn extractBits(vec<N, T>, u32, u32) -> vec<N, T>
@must_use @const implicit(N: num, T: f32_f16) fn faceForward(vec<N, T>, vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: iu32) fn firstLeadingBit(T) -> T
@must_use @const implicit(N: num, T: iu32) fn firstLeadingBit(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: iu32) fn firstTrailingBit(T) -> T
@must_use @const implicit(N: num, T: iu32) fn firstTrailingBit(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn floor(@test_value(1.5) T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn floor(@test_value(1.5) vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn fma(T, T, T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn fma(vec<N, T>, vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn fract(@test_value(1.25) T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn fract(@test_value(1.25) vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn frexp(T) -> __frexp_result<T>
@must_use @const implicit(N: num, T: f32_f16) fn frexp(vec<N, T>) -> __frexp_result_vec<N, T>
@must_use @stage("fragment") fn fwidth(f32) -> f32
@must_use @stage("fragment") implicit(N: num) fn fwidth(vec<N, f32>) -> vec<N, f32>
@must_use @stage("fragment") fn fwidthCoarse(f32) -> f32
@must_use @stage("fragment") implicit(N: num) fn fwidthCoarse(vec<N, f32>) -> vec<N, f32>
@must_use @stage("fragment") fn fwidthFine(f32) -> f32
@must_use @stage("fragment") implicit(N: num) fn fwidthFine(vec<N, f32>) -> vec<N, f32>
@must_use @const implicit(T: iu32) fn insertBits(T, T, u32, u32) -> T
@must_use @const implicit(N: num, T: iu32) fn insertBits(vec<N, T>, vec<N, T>, u32, u32) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn inverseSqrt(T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn inverseSqrt(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16, U: i32) fn ldexp(T, U) -> T
@must_use @const implicit(N: num, T: f32_f16, U: i32) fn ldexp(vec<N, T>, vec<N, U>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn length(@test_value(0.0) T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn length(@test_value(0.0) vec<N, T>) -> T
@must_use @const implicit(T: f32_f16) fn log(T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn log(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn log2(T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn log2(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: fiu32_f16) fn max(T, T) -> T
@must_use @const implicit(N: num, T: fiu32_f16) fn max(vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: fiu32_f16) fn min(T, T) -> T
@must_use @const implicit(N: num, T: fiu32_f16) fn min(vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn mix(T, T, T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn mix(vec<N, T>, vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const implicit(N: num, T: f32_f16) fn mix(vec<N, T>, vec<N, T>, T) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn modf(@test_value(-1.5) T) -> __modf_result<T>
@must_use @const implicit(N: num, T: f32_f16) fn modf(@test_value(-1.5) vec<N, T>) -> __modf_result_vec<N, T>
@must_use @const implicit(N: num, T: f32_f16) fn normalize(vec<N, T>) -> vec<N, T>
@must_use @const fn pack2x16float(vec2<f32>) -> u32
@must_use @const fn pack2x16snorm(vec2<f32>) -> u32
@must_use @const fn pack2x16unorm(vec2<f32>) -> u32
@must_use @const fn pack4x8snorm(vec4<f32>) -> u32
@must_use @const fn pack4x8unorm(vec4<f32>) -> u32
@must_use @const fn pack4xI8(vec4<i32>) -> u32
@must_use @const fn pack4xU8(vec4<u32>) -> u32
@must_use @const fn pack4xI8Clamp(vec4<i32>) -> u32
@must_use @const fn pack4xU8Clamp(vec4<u32>) -> u32
@must_use @const implicit(T: f32_f16) fn pow(T, T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn pow(vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const fn quantizeToF16(f32) -> f32
@must_use @const implicit(N: num) fn quantizeToF16(vec<N, f32>) -> vec<N, f32>
@must_use @const implicit(T: f32_f16) fn radians(T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn radians(vec<N, T>) -> vec<N, T>
@must_use @const implicit(N: num, T: f32_f16) fn reflect(vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const implicit(N: num, T: f32_f16) fn refract(vec<N, T>, vec<N, T>, T) -> vec<N, T>
@must_use @const implicit(T: iu32) fn reverseBits(T) -> T
@must_use @const implicit(N: num, T: iu32) fn reverseBits(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn round(@test_value(3.5) T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn round(@test_value(3.5) vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn saturate(@test_value(2) T) -> T
@must_use @const implicit(T: f32_f16, N: num) fn saturate(@test_value(2) vec<N, T>) -> vec<N, T>
@must_use @const("select_bool") implicit(T: scalar) fn select(T, T, bool) -> T
@must_use @const("select_bool") implicit(T: scalar, N: num) fn select(vec<N, T>, vec<N, T>, bool) -> vec<N, T>
@must_use @const("select_boolvec") implicit(N: num, T: scalar) fn select(vec<N, T>, vec<N, T>, vec<N, bool>) -> vec<N, T>
@must_use @const implicit(T: fi32_f16) fn sign(T) -> T
@must_use @const implicit(N: num, T: fi32_f16) fn sign(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn sin(@test_value(1.57079632679) T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn sin(@test_value(1.57079632679) vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn sinh(T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn sinh(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn smoothstep(@test_value(2) T, @test_value(4) T, @test_value(3) T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn smoothstep(@test_value(2) vec<N, T>, @test_value(4) vec<N, T>, @test_value(3) vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn sqrt(T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn sqrt(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn step(T, T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn step(vec<N, T>, vec<N, T>) -> vec<N, T>
@stage("compute") fn storageBarrier()
@must_use @const implicit(T: f32_f16) fn tan(T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn tan(vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16) fn tanh(T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn tanh(vec<N, T>) -> vec<N, T>
@must_use @const implicit(M: num, N: num, T: f32_f16) fn transpose(mat<M, N, T>) -> mat<N, M, T>
@must_use @const implicit(T: f32_f16) fn trunc(@test_value(1.5) T) -> T
@must_use @const implicit(N: num, T: f32_f16) fn trunc(@test_value(1.5) vec<N, T>) -> vec<N, T>
@must_use @const fn unpack2x16float(u32) -> vec2<f32>
@must_use @const fn unpack2x16snorm(u32) -> vec2<f32>
@must_use @const fn unpack2x16unorm(u32) -> vec2<f32>
@must_use @const fn unpack4x8snorm(u32) -> vec4<f32>
@must_use @const fn unpack4x8unorm(u32) -> vec4<f32>
@must_use @const fn unpack4xI8(u32) -> vec4<i32>
@must_use @const fn unpack4xU8(u32) -> vec4<u32>
@stage("compute") fn workgroupBarrier()

@stage("compute") fn textureBarrier()
@must_use implicit(T: fiu32) fn textureDimensions(texture: texture_1d<T>) -> u32
@must_use implicit(T: fiu32, L: iu32) fn textureDimensions(texture: texture_1d<T>, level: L) -> u32
@must_use implicit(T: fiu32) fn textureDimensions(texture: texture_2d<T>) -> vec2<u32>
@must_use implicit(T: fiu32, L: iu32) fn textureDimensions(texture: texture_2d<T>, level: L) -> vec2<u32>
@must_use implicit(T: fiu32) fn textureDimensions(texture: texture_2d_array<T>) -> vec2<u32>
@must_use implicit(T: fiu32, L: iu32) fn textureDimensions(texture: texture_2d_array<T>, level: L) -> vec2<u32>
@must_use implicit(T: fiu32) fn textureDimensions(texture: texture_3d<T>) -> vec3<u32>
@must_use implicit(T: fiu32, L: iu32) fn textureDimensions(texture: texture_3d<T>, level: L) -> vec3<u32>
@must_use implicit(T: fiu32) fn textureDimensions(texture: texture_cube<T>) -> vec2<u32>
@must_use implicit(T: fiu32, L: iu32) fn textureDimensions(texture: texture_cube<T>, level: L) -> vec2<u32>
@must_use implicit(T: fiu32) fn textureDimensions(texture: texture_cube_array<T>) -> vec2<u32>
@must_use implicit(T: fiu32, L: iu32) fn textureDimensions(texture: texture_cube_array<T>, level: L) -> vec2<u32>
@must_use implicit(T: fiu32) fn textureDimensions(texture: texture_multisampled_2d<T>) -> vec2<u32>
@must_use fn textureDimensions(texture: texture_depth_2d) -> vec2<u32>
@must_use implicit(L: iu32) fn textureDimensions(texture: texture_depth_2d, level: L) -> vec2<u32>
@must_use fn textureDimensions(texture: texture_depth_2d_array) -> vec2<u32>
@must_use implicit(L: iu32) fn textureDimensions(texture: texture_depth_2d_array, level: L) -> vec2<u32>
@must_use fn textureDimensions(texture: texture_depth_cube) -> vec2<u32>
@must_use implicit(L: iu32) fn textureDimensions(texture: texture_depth_cube, level: L) -> vec2<u32>
@must_use fn textureDimensions(texture: texture_depth_cube_array) -> vec2<u32>
@must_use implicit(L: iu32) fn textureDimensions(texture: texture_depth_cube_array, level: L) -> vec2<u32>
@must_use fn textureDimensions(texture: texture_depth_multisampled_2d) -> vec2<u32>
@must_use implicit(F: texel_format, A: access) fn textureDimensions(texture: texture_storage_1d<F, A>) -> u32
@must_use implicit(F: texel_format, A: access) fn textureDimensions(texture: texture_storage_2d<F, A>) -> vec2<u32>
@must_use implicit(F: texel_format, A: access) fn textureDimensions(texture: texture_storage_2d_array<F, A>) -> vec2<u32>
@must_use implicit(F: texel_format, A: access) fn textureDimensions(texture: texture_storage_3d<F, A>) -> vec3<u32>
@must_use fn textureDimensions(texture: texture_external) -> vec2<u32>
@must_use implicit(T: fiu32, C: iu32) fn textureGather(@const component: C, texture: texture_2d<T>, sampler: sampler, coords: vec2<f32>) -> vec4<T>
@must_use implicit(T: fiu32, C: iu32) fn textureGather(@const component: C, texture: texture_2d<T>, sampler: sampler, coords: vec2<f32>, @const offset: vec2<i32>) -> vec4<T>
@must_use implicit(T: fiu32, C: iu32, A: iu32) fn textureGather(@const component: C, texture: texture_2d_array<T>, sampler: sampler, coords: vec2<f32>, array_index: A) -> vec4<T>
@must_use implicit(T: fiu32, C: iu32, A: iu32) fn textureGather(@const component: C, texture: texture_2d_array<T>, sampler: sampler, coords: vec2<f32>, array_index: A, @const offset: vec2<i32>) -> vec4<T>
@must_use implicit(T: fiu32, C: iu32) fn textureGather(@const component: C, texture: texture_cube<T>, sampler: sampler, coords: vec3<f32>) -> vec4<T>
@must_use implicit(T: fiu32, C: iu32, A: iu32) fn textureGather(@const component: C, texture: texture_cube_array<T>, sampler: sampler, coords: vec3<f32>, array_index: A) -> vec4<T>
@must_use fn textureGather(texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>) -> vec4<f32>
@must_use fn textureGather(texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>, @const offset: vec2<i32>) -> vec4<f32>
@must_use implicit(A: iu32) fn textureGather(texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: A) -> vec4<f32>
@must_use implicit(A: iu32) fn textureGather(texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: A, @const offset: vec2<i32>) -> vec4<f32>
@must_use fn textureGather(texture: texture_depth_cube, sampler: sampler, coords: vec3<f32>) -> vec4<f32>
@must_use implicit(A: iu32) fn textureGather(texture: texture_depth_cube_array, sampler: sampler, coords: vec3<f32>, array_index: A) -> vec4<f32>
@must_use fn textureGatherCompare(texture: texture_depth_2d, sampler: sampler_comparison, coords: vec2<f32>, depth_ref: f32) -> vec4<f32>
@must_use fn textureGatherCompare(texture: texture_depth_2d, sampler: sampler_comparison, coords: vec2<f32>, depth_ref: f32, @const offset: vec2<i32>) -> vec4<f32>
@must_use implicit(A: iu32) fn textureGatherCompare(texture: texture_depth_2d_array, sampler: sampler_comparison, coords: vec2<f32>, array_index: A, depth_ref: f32) -> vec4<f32>
@must_use implicit(A: iu32) fn textureGatherCompare(texture: texture_depth_2d_array, sampler: sampler_comparison, coords: vec2<f32>, array_index: A, depth_ref: f32, @const offset: vec2<i32>) -> vec4<f32>
@must_use fn textureGatherCompare(texture: texture_depth_cube, sampler: sampler_comparison, coords: vec3<f32>, depth_ref: f32) -> vec4<f32>
@must_use implicit(A: iu32) fn textureGatherCompare(texture: texture_depth_cube_array, sampler: sampler_comparison, coords: vec3<f32>, array_index: A, depth_ref: f32) -> vec4<f32>
@must_use implicit(T: fiu32) fn textureNumLayers(texture: texture_2d_array<T>) -> u32
@must_use implicit(T: fiu32) fn textureNumLayers(texture: texture_cube_array<T>) -> u32
@must_use fn textureNumLayers(texture: texture_depth_2d_array) -> u32
@must_use fn textureNumLayers(texture: texture_depth_cube_array) -> u32
@must_use implicit(F: texel_format, A: access) fn textureNumLayers(texture: texture_storage_2d_array<F, A>) -> u32
@must_use implicit(T: fiu32) fn textureNumLevels(texture: texture_1d<T>) -> u32
@must_use implicit(T: fiu32) fn textureNumLevels(texture: texture_2d<T>) -> u32
@must_use implicit(T: fiu32) fn textureNumLevels(texture: texture_2d_array<T>) -> u32
@must_use implicit(T: fiu32) fn textureNumLevels(texture: texture_3d<T>) -> u32
@must_use implicit(T: fiu32) fn textureNumLevels(texture: texture_cube<T>) -> u32
@must_use implicit(T: fiu32) fn textureNumLevels(texture: texture_cube_array<T>) -> u32
@must_use fn textureNumLevels(texture: texture_depth_2d) -> u32
@must_use fn textureNumLevels(texture: texture_depth_2d_array) -> u32
@must_use fn textureNumLevels(texture: texture_depth_cube) -> u32
@must_use fn textureNumLevels(texture: texture_depth_cube_array) -> u32
@must_use implicit(T: fiu32) fn textureNumSamples(texture: texture_multisampled_2d<T>) -> u32
@must_use fn textureNumSamples(texture: texture_depth_multisampled_2d) -> u32
@must_use @stage("fragment") fn textureSample(texture: texture_1d<f32>, sampler: sampler, coords: f32) -> vec4<f32>
@must_use @stage("fragment") fn textureSample(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>) -> vec4<f32>
@must_use @stage("fragment") fn textureSample(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, @const offset: vec2<i32>) -> vec4<f32>
@must_use @stage("fragment") implicit(A: iu32) fn textureSample(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A) -> vec4<f32>
@must_use @stage("fragment") implicit(A: iu32) fn textureSample(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A, @const offset: vec2<i32>) -> vec4<f32>
@must_use @stage("fragment") fn textureSample(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>) -> vec4<f32>
@must_use @stage("fragment") fn textureSample(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, @const offset: vec3<i32>) -> vec4<f32>
@must_use @stage("fragment") fn textureSample(texture: texture_cube<f32>, sampler: sampler, coords: vec3<f32>) -> vec4<f32>
@must_use @stage("fragment") implicit(A: iu32) fn textureSample(texture: texture_cube_array<f32>, sampler: sampler, coords: vec3<f32>, array_index: A) -> vec4<f32>
@must_use @stage("fragment") fn textureSample(texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>) -> f32
@must_use @stage("fragment") fn textureSample(texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>, @const offset: vec2<i32>) -> f32
@must_use @stage("fragment") implicit(A: iu32) fn textureSample(texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: A) -> f32
@must_use @stage("fragment") implicit(A: iu32) fn textureSample(texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: A, @const offset: vec2<i32>) -> f32
@must_use @stage("fragment") fn textureSample(texture: texture_depth_cube, sampler: sampler, coords: vec3<f32>) -> f32
@must_use @stage("fragment") implicit(A: iu32) fn textureSample(texture: texture_depth_cube_array, sampler: sampler, coords: vec3<f32>, array_index: A) -> f32
@must_use @stage("fragment") fn textureSampleBias(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, bias: f32) -> vec4<f32>
@must_use @stage("fragment") fn textureSampleBias(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, bias: f32, @const offset: vec2<i32>) -> vec4<f32>
@must_use @stage("fragment") implicit(A: iu32) fn textureSampleBias(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A, bias: f32) -> vec4<f32>
@must_use @stage("fragment") implicit(A: iu32) fn textureSampleBias(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A, bias: f32, @const offset: vec2<i32>) -> vec4<f32>
@must_use @stage("fragment") fn textureSampleBias(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32>
@must_use @stage("fragment") fn textureSampleBias(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, bias: f32, @const offset: vec3<i32>) -> vec4<f32>
@must_use @stage("fragment") fn textureSampleBias(texture: texture_cube<f32>, sampler: sampler, coords: vec3<f32>, bias: f32) -> vec4<f32>
@must_use @stage("fragment") implicit(A: iu32) fn textureSampleBias(texture: texture_cube_array<f32>, sampler: sampler, coords: vec3<f32>, array_index: A, bias: f32) -> vec4<f32>
@must_use @stage("fragment") fn textureSampleCompare(texture: texture_depth_2d, sampler: sampler_comparison, coords: vec2<f32>, depth_ref: f32) -> f32
@must_use @stage("fragment") fn textureSampleCompare(texture: texture_depth_2d, sampler: sampler_comparison, coords: vec2<f32>, depth_ref: f32, @const offset: vec2<i32>) -> f32
@must_use @stage("fragment") implicit(A: iu32) fn textureSampleCompare(texture: texture_depth_2d_array, sampler: sampler_comparison, coords: vec2<f32>, array_index: A, depth_ref: f32) -> f32
@must_use @stage("fragment") implicit(A: iu32) fn textureSampleCompare(texture: texture_depth_2d_array, sampler: sampler_comparison, coords: vec2<f32>, array_index: A, depth_ref: f32, @const offset: vec2<i32>) -> f32
@must_use @stage("fragment") fn textureSampleCompare(texture: texture_depth_cube, sampler: sampler_comparison, coords: vec3<f32>, depth_ref: f32) -> f32
@must_use @stage("fragment") implicit(A: iu32) fn textureSampleCompare(texture: texture_depth_cube_array, sampler: sampler_comparison, coords: vec3<f32>, array_index: A, depth_ref: f32) -> f32
@must_use fn textureSampleCompareLevel(texture: texture_depth_2d, sampler: sampler_comparison, coords: vec2<f32>, depth_ref: f32) -> f32
@must_use fn textureSampleCompareLevel(texture: texture_depth_2d, sampler: sampler_comparison, coords: vec2<f32>, depth_ref: f32, @const offset: vec2<i32>) -> f32
@must_use implicit(A: iu32) fn textureSampleCompareLevel(texture: texture_depth_2d_array, sampler: sampler_comparison, coords: vec2<f32>, array_index: A, depth_ref: f32) -> f32
@must_use implicit(A: iu32) fn textureSampleCompareLevel(texture: texture_depth_2d_array, sampler: sampler_comparison, coords: vec2<f32>, array_index: A, depth_ref: f32, @const offset: vec2<i32>) -> f32
@must_use fn textureSampleCompareLevel(texture: texture_depth_cube, sampler: sampler_comparison, coords: vec3<f32>, depth_ref: f32) -> f32
@must_use implicit(A: iu32) fn textureSampleCompareLevel(texture: texture_depth_cube_array, sampler: sampler_comparison, coords: vec3<f32>, array_index: A, depth_ref: f32) -> f32
@must_use fn textureSampleGrad(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, ddx: vec2<f32>, ddy: vec2<f32>) -> vec4<f32>
@must_use fn textureSampleGrad(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, ddx: vec2<f32>, ddy: vec2<f32>, @const offset: vec2<i32>) -> vec4<f32>
@must_use implicit(A: iu32) fn textureSampleGrad(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A, ddx: vec2<f32>, ddy: vec2<f32>) -> vec4<f32>
@must_use implicit(A: iu32) fn textureSampleGrad(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A, ddx: vec2<f32>, ddy: vec2<f32>, @const offset: vec2<i32>) -> vec4<f32>
@must_use fn textureSampleGrad(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32>
@must_use fn textureSampleGrad(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>, @const offset: vec3<i32>) -> vec4<f32>
@must_use fn textureSampleGrad(texture: texture_cube<f32>, sampler: sampler, coords: vec3<f32>, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32>
@must_use implicit(A: iu32) fn textureSampleGrad(texture: texture_cube_array<f32>, sampler: sampler, coords: vec3<f32>, array_index: A, ddx: vec3<f32>, ddy: vec3<f32>) -> vec4<f32>
@must_use fn textureSampleLevel(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, level: f32) -> vec4<f32>
@must_use fn textureSampleLevel(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>, level: f32, @const offset: vec2<i32>) -> vec4<f32>
@must_use implicit(A: iu32) fn textureSampleLevel(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A, level: f32) -> vec4<f32>
@must_use implicit(A: iu32) fn textureSampleLevel(texture: texture_2d_array<f32>, sampler: sampler, coords: vec2<f32>, array_index: A, level: f32, @const offset: vec2<i32>) -> vec4<f32>
@must_use fn textureSampleLevel(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, level: f32) -> vec4<f32>
@must_use fn textureSampleLevel(texture: texture_3d<f32>, sampler: sampler, coords: vec3<f32>, level: f32, @const offset: vec3<i32>) -> vec4<f32>
@must_use fn textureSampleLevel(texture: texture_cube<f32>, sampler: sampler, coords: vec3<f32>, level: f32) -> vec4<f32>
@must_use implicit(A: iu32) fn textureSampleLevel(texture: texture_cube_array<f32>, sampler: sampler, coords: vec3<f32>, array_index: A, level: f32) -> vec4<f32>
@must_use implicit(L: iu32) fn textureSampleLevel(texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>, level: L) -> f32
@must_use implicit(L: iu32) fn textureSampleLevel(texture: texture_depth_2d, sampler: sampler, coords: vec2<f32>, level: L, @const offset: vec2<i32>) -> f32
@must_use implicit(A: iu32, L: iu32) fn textureSampleLevel(texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: A, level: L) -> f32
@must_use implicit(A: iu32, L: iu32) fn textureSampleLevel(texture: texture_depth_2d_array, sampler: sampler, coords: vec2<f32>, array_index: A, level: L, @const offset: vec2<i32>) -> f32
@must_use implicit(L: iu32) fn textureSampleLevel(texture: texture_depth_cube, sampler: sampler, coords: vec3<f32>, level: L) -> f32
@must_use implicit(A: iu32, L: iu32) fn textureSampleLevel(texture: texture_depth_cube_array,sampler: sampler, coords: vec3<f32>, array_index: A, level: L) -> f32
@must_use fn textureSampleBaseClampToEdge(texture: texture_2d<f32>, sampler: sampler, coords: vec2<f32>) -> vec4<f32>
@must_use fn textureSampleBaseClampToEdge(texture: texture_external, sampler: sampler, coords: vec2<f32>) -> vec4<f32>
implicit(C: iu32) fn textureStore(texture: texture_storage_1d<f32_texel_format, writable>, coords: C, value: vec4<f32>)
implicit(C: iu32) fn textureStore(texture: texture_storage_2d<f32_texel_format, writable>, coords: vec2<C>, value: vec4<f32>)
implicit(C: iu32, A: iu32) fn textureStore(texture: texture_storage_2d_array<f32_texel_format, writable>, coords: vec2<C>, array_index: A, value: vec4<f32>)
implicit(C: iu32) fn textureStore(texture: texture_storage_3d<f32_texel_format, writable>, coords: vec3<C>, value: vec4<f32>)
implicit(C: iu32) fn textureStore(texture: texture_storage_1d<i32_texel_format, writable>, coords: C, value: vec4<i32>)
implicit(C: iu32) fn textureStore(texture: texture_storage_2d<i32_texel_format, writable>, coords: vec2<C>, value: vec4<i32>)
implicit(C: iu32, A: iu32) fn textureStore(texture: texture_storage_2d_array<i32_texel_format, writable>, coords: vec2<C>, array_index: A, value: vec4<i32>)
implicit(C: iu32) fn textureStore(texture: texture_storage_3d<i32_texel_format, writable>, coords: vec3<C>, value: vec4<i32>)
implicit(C: iu32) fn textureStore(texture: texture_storage_1d<u32_texel_format, writable>, coords: C, value: vec4<u32>)
implicit(C: iu32) fn textureStore(texture: texture_storage_2d<u32_texel_format, writable>, coords: vec2<C>, value: vec4<u32>)
implicit(C: iu32, A: iu32) fn textureStore(texture: texture_storage_2d_array<u32_texel_format, writable>, coords: vec2<C>, array_index: A, value: vec4<u32>)
implicit(C: iu32) fn textureStore(texture: texture_storage_3d<u32_texel_format, writable>, coords: vec3<C>, value: vec4<u32>)
@must_use implicit(T: fiu32, C: iu32, L: iu32) fn textureLoad(texture: texture_1d<T>, coords: C, level: L) -> vec4<T>
@must_use implicit(T: fiu32, C: iu32, L: iu32) fn textureLoad(texture: texture_2d<T>, coords: vec2<C>, level: L) -> vec4<T>
@must_use implicit(T: fiu32, C: iu32, A: iu32, L: iu32) fn textureLoad(texture: texture_2d_array<T>, coords: vec2<C>, array_index: A, level: L) -> vec4<T>
@must_use implicit(T: fiu32, C: iu32, L: iu32) fn textureLoad(texture: texture_3d<T>, coords: vec3<C>, level: L) -> vec4<T>
@must_use implicit(T: fiu32, C: iu32, S: iu32) fn textureLoad(texture: texture_multisampled_2d<T>, coords: vec2<C>, sample_index: S) -> vec4<T>
@must_use implicit(C: iu32, L: iu32) fn textureLoad(texture: texture_depth_2d, coords: vec2<C>, level: L) -> f32
@must_use implicit(C: iu32, A: iu32, L: iu32) fn textureLoad(texture: texture_depth_2d_array, coords: vec2<C>, array_index: A, level: L) -> f32
@must_use implicit(C: iu32, S: iu32) fn textureLoad(texture: texture_depth_multisampled_2d, coords: vec2<C>, sample_index: S) -> f32
@must_use implicit(C: iu32) fn textureLoad(texture: texture_external, coords: vec2<C>) -> vec4<f32>
@must_use implicit(C: iu32) fn textureLoad(texture: texture_storage_1d<f32_texel_format, readable>, coords: C) -> vec4<f32>
@must_use implicit(C: iu32) fn textureLoad(texture: texture_storage_1d<i32_texel_format, readable>, coords: C) -> vec4<i32>
@must_use implicit(C: iu32) fn textureLoad(texture: texture_storage_1d<u32_texel_format, readable>, coords: C) -> vec4<u32>
@must_use implicit(C: iu32) fn textureLoad(texture: texture_storage_2d<f32_texel_format, readable>, coords: vec2<C>) -> vec4<f32>
@must_use implicit(C: iu32) fn textureLoad(texture: texture_storage_2d<i32_texel_format, readable>, coords: vec2<C>) -> vec4<i32>
@must_use implicit(C: iu32) fn textureLoad(texture: texture_storage_2d<u32_texel_format, readable>, coords: vec2<C>) -> vec4<u32>
@must_use implicit(C: iu32, A: iu32) fn textureLoad(texture: texture_storage_2d_array<f32_texel_format, readable>, coords: vec2<C>, array_index: A) -> vec4<f32>
@must_use implicit(C: iu32, A: iu32) fn textureLoad(texture: texture_storage_2d_array<i32_texel_format, readable>, coords: vec2<C>, array_index: A) -> vec4<i32>
@must_use implicit(C: iu32, A: iu32) fn textureLoad(texture: texture_storage_2d_array<u32_texel_format, readable>, coords: vec2<C>, array_index: A) -> vec4<u32>
@must_use implicit(C: iu32) fn textureLoad(texture: texture_storage_3d<f32_texel_format, readable>, coords: vec3<C>) -> vec4<f32>
@must_use implicit(C: iu32) fn textureLoad(texture: texture_storage_3d<i32_texel_format, readable>, coords: vec3<C>) -> vec4<i32>
@must_use implicit(C: iu32) fn textureLoad(texture: texture_storage_3d<u32_texel_format, readable>, coords: vec3<C>) -> vec4<u32>

@stage("fragment") implicit(T: fiu32) fn inputAttachmentLoad(input_attachment: input_attachment<T>) -> vec4<T>

@stage("fragment", "compute") implicit(T: iu32, S: workgroup_or_storage) fn atomicLoad(ptr<S, atomic<T>, read_write>) -> T
@stage("fragment", "compute") implicit(T: iu32, S: workgroup_or_storage) fn atomicStore(ptr<S, atomic<T>, read_write>, T)
@stage("fragment", "compute") implicit(T: iu32, S: workgroup_or_storage) fn atomicAdd(ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") implicit(T: iu32, S: workgroup_or_storage) fn atomicSub(ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") implicit(T: iu32, S: workgroup_or_storage) fn atomicMax(ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") implicit(T: iu32, S: workgroup_or_storage) fn atomicMin(ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") implicit(T: iu32, S: workgroup_or_storage) fn atomicAnd(ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") implicit(T: iu32, S: workgroup_or_storage) fn atomicOr(ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") implicit(T: iu32, S: workgroup_or_storage) fn atomicXor(ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") implicit(T: iu32, S: workgroup_or_storage) fn atomicExchange(ptr<S, atomic<T>, read_write>, T) -> T
@stage("fragment", "compute") implicit(T: iu32, S: workgroup_or_storage) fn atomicCompareExchangeWeak(ptr<S, atomic<T>, read_write>, T, T) -> __atomic_compare_exchange_result<T>

@must_use @stage("fragment", "compute") fn subgroupBallot(bool) -> vec4<u32>
@must_use @stage("fragment", "compute") fn subgroupElect() -> bool
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn subgroupBroadcast(value: T, @const sourceLaneIndex: iu32) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn subgroupBroadcast(value: vec<N, T>, @const sourceLaneIndex: iu32) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn subgroupBroadcastFirst(value: T) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn subgroupBroadcastFirst(value: vec<N, T>) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn subgroupShuffle(value: T, sourceLaneIndex: iu32) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn subgroupShuffle(value: vec<N, T>, sourceLaneIndex: iu32) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn subgroupShuffleXor(value: T, mask: u32) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn subgroupShuffleXor(value: vec<N, T>, mask: u32) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn subgroupShuffleUp(value: T, delta: u32) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn subgroupShuffleUp(value: vec<N, T>, delta: u32) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn subgroupShuffleDown(value: T, delta: u32) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn subgroupShuffleDown(value: vec<N, T>, delta: u32) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn subgroupAdd(value: T) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn subgroupAdd(value: vec<N, T>) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn subgroupInclusiveAdd(value: T) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn subgroupInclusiveAdd(value: vec<N, T>) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn subgroupExclusiveAdd(value: T) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn subgroupExclusiveAdd(value: vec<N, T>) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn subgroupMul(value: T) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn subgroupMul(value: vec<N, T>) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn subgroupInclusiveMul(value: T) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn subgroupInclusiveMul(value: vec<N, T>) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn subgroupExclusiveMul(value: T) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn subgroupExclusiveMul(value: vec<N, T>) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: iu32) fn subgroupAnd(value: T) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: iu32) fn subgroupAnd(value: vec<N, T>) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: iu32) fn subgroupOr(value: T) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: iu32) fn subgroupOr(value: vec<N, T>) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: iu32) fn subgroupXor(value: T) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: iu32) fn subgroupXor(value: vec<N, T>) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn subgroupMin(value: T) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn subgroupMin(value: vec<N, T>) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn subgroupMax(value: T) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn subgroupMax(value: vec<N, T>) -> vec<N, T>
@must_use @stage("fragment", "compute") fn subgroupAll(bool) -> bool
@must_use @stage("fragment", "compute") fn subgroupAny(bool) -> bool
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn quadBroadcast(e: T, @const id: iu32) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn quadBroadcast(e: vec<N, T>, @const id: iu32) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn quadSwapX(e: T) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn quadSwapX(e: vec<N, T>) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn quadSwapY(e: T) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn quadSwapY(e: vec<N, T>) -> vec<N, T>
@must_use @stage("fragment", "compute") implicit(T: fiu32_f16) fn quadSwapDiagonal(e: T) -> T
@must_use @stage("fragment", "compute") implicit(N: num, T: fiu32_f16) fn quadSwapDiagonal(e: vec<N, T>) -> vec<N, T>

@stage("compute") implicit(K: subgroup_matrix_kind, S: fiu32_f16, C: num, R: num) fn subgroupMatrixLoad<T: subgroup_matrix<K, S, C, R> >(ptr<storage, runtime_array<S>, readable>, u32, @const bool, u32) -> T
@stage("compute") implicit(K: subgroup_matrix_kind, S: fiu32_f16, C: num, R: num, AC: num) fn subgroupMatrixLoad<T: subgroup_matrix<K, S, C, R> >(ptr<workgroup_or_storage, array<S, AC>, readable>, u32, @const bool, u32) -> T
@stage("compute") implicit(K: subgroup_matrix_kind, S: fiu32_f16, C: num, R: num) fn subgroupMatrixStore(ptr<storage, runtime_array<S>, writable>, u32, subgroup_matrix<K, S, C, R>, @const bool, u32)
@stage("compute") implicit(K: subgroup_matrix_kind, S: fiu32_f16, C: num, R: num, AC: num) fn subgroupMatrixStore(ptr<workgroup_or_storage, array<S, AC>, writable>, u32, subgroup_matrix<K, S, C, R>, @const bool, u32)
@must_use @stage("compute") implicit(T: subgroup_matrix_elements, C: num, R: num, K: num) fn subgroupMatrixMultiply<TR: subgroup_matrix_elements>(
  subgroup_matrix<subgroup_matrix_kind_left, T, K, R>,
  subgroup_matrix<subgroup_matrix_kind_right, T, C, K>)
  -> subgroup_matrix<subgroup_matrix_kind_result, TR, C, R>
@must_use @stage("compute") implicit(T: subgroup_matrix_elements, TR: subgroup_matrix_elements, C: num, R: num, K: num) fn subgroupMatrixMultiplyAccumulate(
  subgroup_matrix<subgroup_matrix_kind_left, T, K, R>,
  subgroup_matrix<subgroup_matrix_kind_right, T, C, K>,
  subgroup_matrix<subgroup_matrix_kind_result, TR, C, R>)
  -> subgroup_matrix<subgroup_matrix_kind_result, TR, C, R>

////////////////////////////////////////////////////////////////////////////////
// Value constructors                                                         //
////////////////////////////////////////////////////////////////////////////////

// Zero value constructors
@must_use @const("Zero") ctor i32() -> i32
@must_use @const("Zero") ctor u32() -> u32
@must_use @const("Zero") ctor f32() -> f32
@must_use @const("Zero") ctor f16() -> f16
@must_use @const("Zero") ctor bool() -> bool
@must_use @const("Zero") ctor vec2<T: scalar>() -> vec2<T>
@must_use @const("Zero") ctor vec3<T: scalar>() -> vec3<T>
@must_use @const("Zero") ctor vec4<T: scalar>() -> vec4<T>
@must_use @const("Zero") ctor mat2x2<T: f32_f16>() -> mat2x2<T>
@must_use @const("Zero") ctor mat2x3<T: f32_f16>() -> mat2x3<T>
@must_use @const("Zero") ctor mat2x4<T: f32_f16>() -> mat2x4<T>
@must_use @const("Zero") ctor mat3x2<T: f32_f16>() -> mat3x2<T>
@must_use @const("Zero") ctor mat3x3<T: f32_f16>() -> mat3x3<T>
@must_use @const("Zero") ctor mat3x4<T: f32_f16>() -> mat3x4<T>
@must_use @const("Zero") ctor mat4x2<T: f32_f16>() -> mat4x2<T>
@must_use @const("Zero") ctor mat4x3<T: f32_f16>() -> mat4x3<T>
@must_use @const("Zero") ctor mat4x4<T: f32_f16>() -> mat4x4<T>

@must_use @stage("compute") ctor subgroup_matrix_left<T: subgroup_matrix_elements, K: num, R: num>() -> subgroup_matrix<subgroup_matrix_kind_left, T, K, R>
@must_use @stage("compute") ctor subgroup_matrix_right<T: subgroup_matrix_elements, C: num, K: num>() -> subgroup_matrix<subgroup_matrix_kind_right, T, C, K>
@must_use @stage("compute") ctor subgroup_matrix_result<T: subgroup_matrix_elements, C: num, R: num>() -> subgroup_matrix<subgroup_matrix_kind_result, T, C, R>

// Identity constructors
@must_use @const("Identity") ctor i32(i32) -> i32
@must_use @const("Identity") ctor u32(u32) -> u32
@must_use @const("Identity") ctor f32(f32) -> f32
@must_use @const("Identity") ctor f16(f16) -> f16
@must_use @const("Identity") ctor bool(bool) -> bool
@must_use @const("Identity") ctor vec2<T: scalar>(vec2<T>) -> vec2<T>
@must_use @const("Identity") ctor vec3<T: scalar>(vec3<T>) -> vec3<T>
@must_use @const("Identity") ctor vec4<T: scalar>(vec4<T>) -> vec4<T>
@must_use @const("Identity") ctor mat2x2<T: f32_f16>(mat2x2<T>) -> mat2x2<T>
@must_use @const("Identity") ctor mat2x3<T: f32_f16>(mat2x3<T>) -> mat2x3<T>
@must_use @const("Identity") ctor mat2x4<T: f32_f16>(mat2x4<T>) -> mat2x4<T>
@must_use @const("Identity") ctor mat3x2<T: f32_f16>(mat3x2<T>) -> mat3x2<T>
@must_use @const("Identity") ctor mat3x3<T: f32_f16>(mat3x3<T>) -> mat3x3<T>
@must_use @const("Identity") ctor mat3x4<T: f32_f16>(mat3x4<T>) -> mat3x4<T>
@must_use @const("Identity") ctor mat4x2<T: f32_f16>(mat4x2<T>) -> mat4x2<T>
@must_use @const("Identity") ctor mat4x3<T: f32_f16>(mat4x3<T>) -> mat4x3<T>
@must_use @const("Identity") ctor mat4x4<T: f32_f16>(mat4x4<T>) -> mat4x4<T>

// Vector constructors (splat)
@must_use @const("VecSplat") ctor vec2<T: scalar>(T) -> vec2<T>
@must_use @const("VecSplat") ctor vec3<T: scalar>(T) -> vec3<T>
@must_use @const("VecSplat") ctor vec4<T: scalar>(T) -> vec4<T>

// Vector constructors (scalar)
@must_use @const("VecInitS") ctor vec2<T: scalar>(x: T, y: T) -> vec2<T>
@must_use @const("VecInitS") ctor vec3<T: scalar>(x: T, y: T, z: T) -> vec3<T>
@must_use @const("VecInitS") ctor vec4<T: scalar>(x: T, y: T, z: T, w: T) -> vec4<T>

// Vector constructors (mixed)
@must_use @const("VecInitM") ctor vec3<T: scalar>(xy: vec2<T>, z: T) -> vec3<T>
@must_use @const("VecInitM") ctor vec3<T: scalar>(x: T, yz: vec2<T>) -> vec3<T>
@must_use @const("VecInitM") ctor vec4<T: scalar>(xy: vec2<T>, z: T, w: T) -> vec4<T>
@must_use @const("VecInitM") ctor vec4<T: scalar>(x: T, yz: vec2<T>, w: T) -> vec4<T>
@must_use @const("VecInitM") ctor vec4<T: scalar>(x: T, y: T, zw: vec2<T>) -> vec4<T>
@must_use @const("VecInitM") ctor vec4<T: scalar>(xy: vec2<T>, zw: vec2<T>) -> vec4<T>
@must_use @const("VecInitM") ctor vec4<T: scalar>(xyz: vec3<T>, w: T) -> vec4<T>
@must_use @const("VecInitM") ctor vec4<T: scalar>(x: T, zyw: vec3<T>) -> vec4<T>

// Matrix constructors (scalar)
@must_use @const("MatInitS")
ctor mat2x2<T: f32_f16>(T, T,
                        T, T) -> mat2x2<T>

@must_use @const("MatInitS")
ctor mat2x3<T: f32_f16>(T, T, T,
                        T, T, T) -> mat2x3<T>

@must_use @const("MatInitS")
ctor mat2x4<T: f32_f16>(T, T, T, T,
                        T, T, T, T) -> mat2x4<T>

@must_use @const("MatInitS")
ctor mat3x2<T: f32_f16>(T, T,
                        T, T,
                        T, T) -> mat3x2<T>

@must_use @const("MatInitS")
ctor mat3x3<T: f32_f16>(T, T, T,
                        T, T, T,
                        T, T, T) -> mat3x3<T>

@must_use @const("MatInitS")
ctor mat3x4<T: f32_f16>(T, T, T, T,
                        T, T, T, T,
                        T, T, T, T) -> mat3x4<T>

@must_use @const("MatInitS")
ctor mat4x2<T: f32_f16>(T, T,
                        T, T,
                        T, T,
                        T, T) -> mat4x2<T>

@must_use @const("MatInitS")
ctor mat4x3<T: f32_f16>(T, T, T,
                        T, T, T,
                        T, T, T,
                        T, T, T) -> mat4x3<T>

@must_use @const("MatInitS")
ctor mat4x4<T: f32_f16>(T, T, T, T,
                        T, T, T, T,
                        T, T, T, T,
                        T, T, T, T) -> mat4x4<T>

// Matrix constructors (column vectors)
@must_use @const("MatInitV") ctor mat2x2<T: f32_f16>(vec2<T>, vec2<T>) -> mat2x2<T>
@must_use @const("MatInitV") ctor mat2x3<T: f32_f16>(vec3<T>, vec3<T>) -> mat2x3<T>
@must_use @const("MatInitV") ctor mat2x4<T: f32_f16>(vec4<T>, vec4<T>) -> mat2x4<T>
@must_use @const("MatInitV") ctor mat3x2<T: f32_f16>(vec2<T>, vec2<T>, vec2<T>) -> mat3x2<T>
@must_use @const("MatInitV") ctor mat3x3<T: f32_f16>(vec3<T>, vec3<T>, vec3<T>) -> mat3x3<T>
@must_use @const("MatInitV") ctor mat3x4<T: f32_f16>(vec4<T>, vec4<T>, vec4<T>) -> mat3x4<T>
@must_use @const("MatInitV") ctor mat4x2<T: f32_f16>(vec2<T>, vec2<T>, vec2<T>, vec2<T>) -> mat4x2<T>
@must_use @const("MatInitV") ctor mat4x3<T: f32_f16>(vec3<T>, vec3<T>, vec3<T>, vec3<T>) -> mat4x3<T>
@must_use @const("MatInitV") ctor mat4x4<T: f32_f16>(vec4<T>, vec4<T>, vec4<T>, vec4<T>) -> mat4x4<T>

////////////////////////////////////////////////////////////////////////////////
// Value conversions                                                          //
////////////////////////////////////////////////////////////////////////////////
@must_use @const implicit(T: scalar_no_f32) conv f32(T) -> f32
@must_use @const implicit(T: scalar_no_f16) conv f16(T) -> f16
@must_use @const implicit(T: scalar_no_i32) conv i32(T) -> i32
@must_use @const implicit(T: scalar_no_u32) conv u32(T) -> u32
@must_use @const implicit(T: scalar_no_bool) conv bool(T) -> bool

@must_use @const implicit(U: scalar_no_f32) conv vec2<T: f32>(vec2<U>) -> vec2<T>
@must_use @const implicit(U: scalar_no_f16) conv vec2<T: f16>(vec2<U>) -> vec2<T>
@must_use @const implicit(U: scalar_no_i32) conv vec2<T: i32>(vec2<U>) -> vec2<T>
@must_use @const implicit(U: scalar_no_u32) conv vec2<T: u32>(vec2<U>) -> vec2<T>
@must_use @const implicit(U: scalar_no_bool) conv vec2<T: bool>(vec2<U>) -> vec2<T>

@must_use @const implicit(U: scalar_no_f32) conv vec3<T: f32>(vec3<U>) -> vec3<T>
@must_use @const implicit(U: scalar_no_f16) conv vec3<T: f16>(vec3<U>) -> vec3<T>
@must_use @const implicit(U: scalar_no_i32) conv vec3<T: i32>(vec3<U>) -> vec3<T>
@must_use @const implicit(U: scalar_no_u32) conv vec3<T: u32>(vec3<U>) -> vec3<T>
@must_use @const implicit(U: scalar_no_bool) conv vec3<T: bool>(vec3<U>) -> vec3<T>

@must_use @const implicit(U: scalar_no_f32) conv vec4<T: f32>(vec4<U>) -> vec4<T>
@must_use @const implicit(U: scalar_no_f16) conv vec4<T: f16>(vec4<U>) -> vec4<T>
@must_use @const implicit(U: scalar_no_i32) conv vec4<T: i32>(vec4<U>) -> vec4<T>
@must_use @const implicit(U: scalar_no_u32) conv vec4<T: u32>(vec4<U>) -> vec4<T>
@must_use @const implicit(U: scalar_no_bool) conv vec4<T: bool>(vec4<U>) -> vec4<T>

@must_use @const conv mat2x2<T: f16>(mat2x2<f32>) -> mat2x2<T>
@must_use @const conv mat2x2<T: f32>(mat2x2<f16>) -> mat2x2<T>
@must_use @const conv mat2x3<T: f16>(mat2x3<f32>) -> mat2x3<T>
@must_use @const conv mat2x3<T: f32>(mat2x3<f16>) -> mat2x3<T>
@must_use @const conv mat2x4<T: f16>(mat2x4<f32>) -> mat2x4<T>
@must_use @const conv mat2x4<T: f32>(mat2x4<f16>) -> mat2x4<T>
@must_use @const conv mat3x2<T: f16>(mat3x2<f32>) -> mat3x2<T>
@must_use @const conv mat3x2<T: f32>(mat3x2<f16>) -> mat3x2<T>
@must_use @const conv mat3x3<T: f16>(mat3x3<f32>) -> mat3x3<T>
@must_use @const conv mat3x3<T: f32>(mat3x3<f16>) -> mat3x3<T>
@must_use @const conv mat3x4<T: f16>(mat3x4<f32>) -> mat3x4<T>
@must_use @const conv mat3x4<T: f32>(mat3x4<f16>) -> mat3x4<T>
@must_use @const conv mat4x2<T: f16>(mat4x2<f32>) -> mat4x2<T>
@must_use @const conv mat4x2<T: f32>(mat4x2<f16>) -> mat4x2<T>
@must_use @const conv mat4x3<T: f16>(mat4x3<f32>) -> mat4x3<T>
@must_use @const conv mat4x3<T: f32>(mat4x3<f16>) -> mat4x3<T>
@must_use @const conv mat4x4<T: f16>(mat4x4<f32>) -> mat4x4<T>
@must_use @const conv mat4x4<T: f32>(mat4x4<f16>) -> mat4x4<T>

////////////////////////////////////////////////////////////////////////////////
// Unary Operators                                                            //
////////////////////////////////////////////////////////////////////////////////
@must_use @const op ! (bool) -> bool
@must_use @const implicit(N: num) op ! (vec<N, bool>) -> vec<N, bool>

@must_use @const implicit(T: iu32) op ~ (T) -> T
@must_use @const implicit(T: iu32, N: num) op ~ (vec<N, T>) -> vec<N, T>

@must_use @const("UnaryMinus") implicit(T: fi32_f16) op - (T) -> T
@must_use @const("UnaryMinus") implicit(T: fi32_f16, N: num) op - (vec<N, T>) -> vec<N, T>

////////////////////////////////////////////////////////////////////////////////
// Binary Operators                                                           //
////////////////////////////////////////////////////////////////////////////////
@must_use @const implicit(T: fiu32_f16) op + (T, T) -> T
@must_use @const implicit(T: fiu32_f16, N: num) op + (vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: fiu32_f16, N: num) op + (vec<N, T>, T) -> vec<N, T>
@must_use @const implicit(T: fiu32_f16, N: num) op + (T, vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16, N: num, M: num) op + (mat<N, M, T>, mat<N, M, T>) -> mat<N, M, T>

@must_use @const implicit(T: fiu32_f16) op - (T, T) -> T
@must_use @const implicit(T: fiu32_f16, N: num) op - (vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: fiu32_f16, N: num) op - (vec<N, T>, T) -> vec<N, T>
@must_use @const implicit(T: fiu32_f16, N: num) op - (T, vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: f32_f16, N: num, M: num) op - (mat<N, M, T>, mat<N, M, T>) -> mat<N, M, T>

@must_use @const("Multiply") implicit(T: fiu32_f16) op * (T, T) -> T
@must_use @const("Multiply") implicit(T: fiu32_f16, N: num) op * (vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const("Multiply") implicit(T: fiu32_f16, N: num) op * (vec<N, T>, T) -> vec<N, T>
@must_use @const("Multiply") implicit(T: fiu32_f16, N: num) op * (T, vec<N, T>) -> vec<N, T>
@must_use @const("Multiply") implicit(T: f32_f16, N: num, M: num) op * (T, mat<N, M, T>) -> mat<N, M, T>
@must_use @const("Multiply") implicit(T: f32_f16, N: num, M: num) op * (mat<N, M, T>, T) -> mat<N, M, T>
@must_use @const("MultiplyMatVec") implicit(T: f32_f16, C: num, R: num) op * (mat<C, R, T>, vec<C, T>) -> vec<R, T>
@must_use @const("MultiplyVecMat") implicit(T: f32_f16, C: num, R: num) op * (vec<R, T>, mat<C, R, T>) -> vec<C, T>
@must_use @const("MultiplyMatMat") implicit(T: f32_f16, K: num, C: num, R: num) op * (mat<K, R, T>, mat<C, K, T>) -> mat<C, R, T>

@must_use @const implicit(T: fiu32_f16) op / (T, T) -> T
@must_use @const implicit(T: fiu32_f16, N: num) op / (vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: fiu32_f16, N: num) op / (vec<N, T>, T) -> vec<N, T>
@must_use @const implicit(T: fiu32_f16, N: num) op / (T, vec<N, T>) -> vec<N, T>

@must_use @const implicit(T: fiu32_f16) op % (T, T) -> T
@must_use @const implicit(T: fiu32_f16, N: num) op % (vec<N, T>, vec<N, T>) -> vec<N, T>
@must_use @const implicit(T: fiu32_f16, N: num) op % (vec<N, T>, T) -> vec<N, T>
@must_use @const implicit(T: fiu32_f16, N: num) op % (T, vec<N, T>) -> vec<N, T>

@must_use @const implicit(T: iu32) op ^ (T, T) -> T
@must_use @const implicit(T: iu32, N: num) op ^ (vec<N, T>, vec<N, T>) -> vec<N, T>

@must_use @const op & (bool, bool) -> bool
@must_use @const implicit(N: num) op & (vec<N, bool>, vec<N, bool>) -> vec<N, bool>
@must_use @const implicit(T: iu32) op & (T, T) -> T
@must_use @const implicit(T: iu32, N: num) op & (vec<N, T>, vec<N, T>) -> vec<N, T>

@must_use @const op | (bool, bool) -> bool
@must_use @const implicit(N: num) op | (vec<N, bool>, vec<N, bool>) -> vec<N, bool>
@must_use @const implicit(T: iu32) op | (T, T) -> T
@must_use @const implicit(T: iu32, N: num) op | (vec<N, T>, vec<N, T>) -> vec<N, T>

@must_use @const op && (bool, bool) -> bool
@must_use @const op || (bool, bool) -> bool

@must_use @const implicit(T: scalar) op == (T, T) -> bool
@must_use @const implicit(T: scalar, N: num) op == (vec<N, T>, vec<N, T>) -> vec<N, bool>

@must_use @const implicit(T: scalar) op != (T, T) -> bool
@must_use @const implicit(T: scalar, N: num) op != (vec<N, T>, vec<N, T>) -> vec<N, bool>

@must_use @const implicit(T: fiu32_f16) op < (T, T) -> bool
@must_use @const implicit(T: fiu32_f16, N: num) op < (vec<N, T>, vec<N, T>) -> vec<N, bool>

@must_use @const implicit(T: fiu32_f16) op > (T, T) -> bool
@must_use @const implicit(T: fiu32_f16, N: num) op > (vec<N, T>, vec<N, T>) -> vec<N, bool>

@must_use @const implicit(T: fiu32_f16) op <= (T, T) -> bool
@must_use @const implicit(T: fiu32_f16, N: num) op <= (vec<N, T>, vec<N, T>) -> vec<N, bool>

@must_use @const implicit(T: fiu32_f16) op >= (T, T) -> bool
@must_use @const implicit(T: fiu32_f16, N: num) op >= (vec<N, T>, vec<N, T>) -> vec<N, bool>

@must_use @const implicit(T: iu32) op << (T, u32) -> T
@must_use @const implicit(T: iu32, N: num) op << (vec<N, T>, vec<N, u32>) -> vec<N, T>

@must_use @const implicit(T: iu32) op >> (T, u32) -> T
@must_use @const implicit(T: iu32, N: num) op >> (vec<N, T>, vec<N, u32>) -> vec<N, T>
