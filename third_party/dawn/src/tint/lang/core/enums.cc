// Copyright 2025 The Dawn & Tint Authors
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

////////////////////////////////////////////////////////////////////////////////
// File generated by 'tools/src/cmd/gen' using the template:
//   src/tint/lang/core/enums.cc.tmpl
//
// To regenerate run: './tools/run gen'
//
//                       Do not modify this file directly
////////////////////////////////////////////////////////////////////////////////

#include "src/tint/lang/core/enums.h"

namespace tint::core {

/// ParseAccess parses a Access from a string.
/// @param str the string to parse
/// @returns the parsed enum, or Access::kUndefined if the string could not be parsed.
Access ParseAccess(std::string_view str) {
    if (str == "read") {
        return Access::kRead;
    }
    if (str == "read_write") {
        return Access::kReadWrite;
    }
    if (str == "write") {
        return Access::kWrite;
    }
    return Access::kUndefined;
}
std::string_view ToString(Access value) {
    switch (value) {
        case Access::kUndefined:
            return "undefined";
        case Access::kRead:
            return "read";
        case Access::kReadWrite:
            return "read_write";
        case Access::kWrite:
            return "write";
    }
    return "<unknown>";
}

/// ParseAddressSpace parses a AddressSpace from a string.
/// @param str the string to parse
/// @returns the parsed enum, or AddressSpace::kUndefined if the string could not be parsed.
AddressSpace ParseAddressSpace(std::string_view str) {
    if (str == "function") {
        return AddressSpace::kFunction;
    }
    if (str == "immediate") {
        return AddressSpace::kImmediate;
    }
    if (str == "pixel_local") {
        return AddressSpace::kPixelLocal;
    }
    if (str == "private") {
        return AddressSpace::kPrivate;
    }
    if (str == "storage") {
        return AddressSpace::kStorage;
    }
    if (str == "uniform") {
        return AddressSpace::kUniform;
    }
    if (str == "workgroup") {
        return AddressSpace::kWorkgroup;
    }
    return AddressSpace::kUndefined;
}
std::string_view ToString(AddressSpace value) {
    switch (value) {
        case AddressSpace::kUndefined:
            return "undefined";
        case AddressSpace::kIn:
            return "__in";
        case AddressSpace::kOut:
            return "__out";
        case AddressSpace::kFunction:
            return "function";
        case AddressSpace::kHandle:
            return "handle";
        case AddressSpace::kImmediate:
            return "immediate";
        case AddressSpace::kPixelLocal:
            return "pixel_local";
        case AddressSpace::kPrivate:
            return "private";
        case AddressSpace::kStorage:
            return "storage";
        case AddressSpace::kUniform:
            return "uniform";
        case AddressSpace::kWorkgroup:
            return "workgroup";
    }
    return "<unknown>";
}

/// ParseInterpolationSampling parses a InterpolationSampling from a string.
/// @param str the string to parse
/// @returns the parsed enum, or InterpolationSampling::kUndefined if the string could not be
/// parsed.
InterpolationSampling ParseInterpolationSampling(std::string_view str) {
    if (str == "center") {
        return InterpolationSampling::kCenter;
    }
    if (str == "centroid") {
        return InterpolationSampling::kCentroid;
    }
    if (str == "either") {
        return InterpolationSampling::kEither;
    }
    if (str == "first") {
        return InterpolationSampling::kFirst;
    }
    if (str == "sample") {
        return InterpolationSampling::kSample;
    }
    return InterpolationSampling::kUndefined;
}
std::string_view ToString(InterpolationSampling value) {
    switch (value) {
        case InterpolationSampling::kUndefined:
            return "undefined";
        case InterpolationSampling::kCenter:
            return "center";
        case InterpolationSampling::kCentroid:
            return "centroid";
        case InterpolationSampling::kEither:
            return "either";
        case InterpolationSampling::kFirst:
            return "first";
        case InterpolationSampling::kSample:
            return "sample";
    }
    return "<unknown>";
}

/// ParseInterpolationType parses a InterpolationType from a string.
/// @param str the string to parse
/// @returns the parsed enum, or InterpolationType::kUndefined if the string could not be parsed.
InterpolationType ParseInterpolationType(std::string_view str) {
    if (str == "flat") {
        return InterpolationType::kFlat;
    }
    if (str == "linear") {
        return InterpolationType::kLinear;
    }
    if (str == "perspective") {
        return InterpolationType::kPerspective;
    }
    return InterpolationType::kUndefined;
}
std::string_view ToString(InterpolationType value) {
    switch (value) {
        case InterpolationType::kUndefined:
            return "undefined";
        case InterpolationType::kFlat:
            return "flat";
        case InterpolationType::kLinear:
            return "linear";
        case InterpolationType::kPerspective:
            return "perspective";
    }
    return "<unknown>";
}

/// ParseSubgroupMatrixKind parses a SubgroupMatrixKind from a string.
/// @param str the string to parse
/// @returns the parsed enum, or SubgroupMatrixKind::kUndefined if the string could not be parsed.
SubgroupMatrixKind ParseSubgroupMatrixKind(std::string_view str) {
    if (str == "left") {
        return SubgroupMatrixKind::kLeft;
    }
    if (str == "result") {
        return SubgroupMatrixKind::kResult;
    }
    if (str == "right") {
        return SubgroupMatrixKind::kRight;
    }
    return SubgroupMatrixKind::kUndefined;
}
std::string_view ToString(SubgroupMatrixKind value) {
    switch (value) {
        case SubgroupMatrixKind::kUndefined:
            return "undefined";
        case SubgroupMatrixKind::kLeft:
            return "left";
        case SubgroupMatrixKind::kResult:
            return "result";
        case SubgroupMatrixKind::kRight:
            return "right";
    }
    return "<unknown>";
}

/// ParseTexelFormat parses a TexelFormat from a string.
/// @param str the string to parse
/// @returns the parsed enum, or TexelFormat::kUndefined if the string could not be parsed.
TexelFormat ParseTexelFormat(std::string_view str) {
    if (str == "bgra8unorm") {
        return TexelFormat::kBgra8Unorm;
    }
    if (str == "r16float") {
        return TexelFormat::kR16Float;
    }
    if (str == "r16sint") {
        return TexelFormat::kR16Sint;
    }
    if (str == "r16snorm") {
        return TexelFormat::kR16Snorm;
    }
    if (str == "r16uint") {
        return TexelFormat::kR16Uint;
    }
    if (str == "r16unorm") {
        return TexelFormat::kR16Unorm;
    }
    if (str == "r32float") {
        return TexelFormat::kR32Float;
    }
    if (str == "r32sint") {
        return TexelFormat::kR32Sint;
    }
    if (str == "r32uint") {
        return TexelFormat::kR32Uint;
    }
    if (str == "r8sint") {
        return TexelFormat::kR8Sint;
    }
    if (str == "r8snorm") {
        return TexelFormat::kR8Snorm;
    }
    if (str == "r8uint") {
        return TexelFormat::kR8Uint;
    }
    if (str == "r8unorm") {
        return TexelFormat::kR8Unorm;
    }
    if (str == "rg11b10ufloat") {
        return TexelFormat::kRg11B10Ufloat;
    }
    if (str == "rg16float") {
        return TexelFormat::kRg16Float;
    }
    if (str == "rg16sint") {
        return TexelFormat::kRg16Sint;
    }
    if (str == "rg16snorm") {
        return TexelFormat::kRg16Snorm;
    }
    if (str == "rg16uint") {
        return TexelFormat::kRg16Uint;
    }
    if (str == "rg16unorm") {
        return TexelFormat::kRg16Unorm;
    }
    if (str == "rg32float") {
        return TexelFormat::kRg32Float;
    }
    if (str == "rg32sint") {
        return TexelFormat::kRg32Sint;
    }
    if (str == "rg32uint") {
        return TexelFormat::kRg32Uint;
    }
    if (str == "rg8sint") {
        return TexelFormat::kRg8Sint;
    }
    if (str == "rg8snorm") {
        return TexelFormat::kRg8Snorm;
    }
    if (str == "rg8uint") {
        return TexelFormat::kRg8Uint;
    }
    if (str == "rg8unorm") {
        return TexelFormat::kRg8Unorm;
    }
    if (str == "rgb10a2uint") {
        return TexelFormat::kRgb10A2Uint;
    }
    if (str == "rgb10a2unorm") {
        return TexelFormat::kRgb10A2Unorm;
    }
    if (str == "rgba16float") {
        return TexelFormat::kRgba16Float;
    }
    if (str == "rgba16sint") {
        return TexelFormat::kRgba16Sint;
    }
    if (str == "rgba16snorm") {
        return TexelFormat::kRgba16Snorm;
    }
    if (str == "rgba16uint") {
        return TexelFormat::kRgba16Uint;
    }
    if (str == "rgba16unorm") {
        return TexelFormat::kRgba16Unorm;
    }
    if (str == "rgba32float") {
        return TexelFormat::kRgba32Float;
    }
    if (str == "rgba32sint") {
        return TexelFormat::kRgba32Sint;
    }
    if (str == "rgba32uint") {
        return TexelFormat::kRgba32Uint;
    }
    if (str == "rgba8sint") {
        return TexelFormat::kRgba8Sint;
    }
    if (str == "rgba8snorm") {
        return TexelFormat::kRgba8Snorm;
    }
    if (str == "rgba8uint") {
        return TexelFormat::kRgba8Uint;
    }
    if (str == "rgba8unorm") {
        return TexelFormat::kRgba8Unorm;
    }
    return TexelFormat::kUndefined;
}
std::string_view ToString(TexelFormat value) {
    switch (value) {
        case TexelFormat::kUndefined:
            return "undefined";
        case TexelFormat::kBgra8Unorm:
            return "bgra8unorm";
        case TexelFormat::kR16Float:
            return "r16float";
        case TexelFormat::kR16Sint:
            return "r16sint";
        case TexelFormat::kR16Snorm:
            return "r16snorm";
        case TexelFormat::kR16Uint:
            return "r16uint";
        case TexelFormat::kR16Unorm:
            return "r16unorm";
        case TexelFormat::kR32Float:
            return "r32float";
        case TexelFormat::kR32Sint:
            return "r32sint";
        case TexelFormat::kR32Uint:
            return "r32uint";
        case TexelFormat::kR8Sint:
            return "r8sint";
        case TexelFormat::kR8Snorm:
            return "r8snorm";
        case TexelFormat::kR8Uint:
            return "r8uint";
        case TexelFormat::kR8Unorm:
            return "r8unorm";
        case TexelFormat::kRg11B10Ufloat:
            return "rg11b10ufloat";
        case TexelFormat::kRg16Float:
            return "rg16float";
        case TexelFormat::kRg16Sint:
            return "rg16sint";
        case TexelFormat::kRg16Snorm:
            return "rg16snorm";
        case TexelFormat::kRg16Uint:
            return "rg16uint";
        case TexelFormat::kRg16Unorm:
            return "rg16unorm";
        case TexelFormat::kRg32Float:
            return "rg32float";
        case TexelFormat::kRg32Sint:
            return "rg32sint";
        case TexelFormat::kRg32Uint:
            return "rg32uint";
        case TexelFormat::kRg8Sint:
            return "rg8sint";
        case TexelFormat::kRg8Snorm:
            return "rg8snorm";
        case TexelFormat::kRg8Uint:
            return "rg8uint";
        case TexelFormat::kRg8Unorm:
            return "rg8unorm";
        case TexelFormat::kRgb10A2Uint:
            return "rgb10a2uint";
        case TexelFormat::kRgb10A2Unorm:
            return "rgb10a2unorm";
        case TexelFormat::kRgba16Float:
            return "rgba16float";
        case TexelFormat::kRgba16Sint:
            return "rgba16sint";
        case TexelFormat::kRgba16Snorm:
            return "rgba16snorm";
        case TexelFormat::kRgba16Uint:
            return "rgba16uint";
        case TexelFormat::kRgba16Unorm:
            return "rgba16unorm";
        case TexelFormat::kRgba32Float:
            return "rgba32float";
        case TexelFormat::kRgba32Sint:
            return "rgba32sint";
        case TexelFormat::kRgba32Uint:
            return "rgba32uint";
        case TexelFormat::kRgba8Sint:
            return "rgba8sint";
        case TexelFormat::kRgba8Snorm:
            return "rgba8snorm";
        case TexelFormat::kRgba8Uint:
            return "rgba8uint";
        case TexelFormat::kRgba8Unorm:
            return "rgba8unorm";
    }
    return "<unknown>";
}

/// ParseBuiltinType parses a BuiltinType from a string.
/// @param str the string to parse
/// @returns the parsed enum, or BuiltinType::kUndefined if the string could not be parsed.
BuiltinType ParseBuiltinType(std::string_view str) {
    if (str == "__atomic_compare_exchange_result_i32") {
        return BuiltinType::kAtomicCompareExchangeResultI32;
    }
    if (str == "__atomic_compare_exchange_result_u32") {
        return BuiltinType::kAtomicCompareExchangeResultU32;
    }
    if (str == "__frexp_result_abstract") {
        return BuiltinType::kFrexpResultAbstract;
    }
    if (str == "__frexp_result_f16") {
        return BuiltinType::kFrexpResultF16;
    }
    if (str == "__frexp_result_f32") {
        return BuiltinType::kFrexpResultF32;
    }
    if (str == "__frexp_result_vec2_abstract") {
        return BuiltinType::kFrexpResultVec2Abstract;
    }
    if (str == "__frexp_result_vec2_f16") {
        return BuiltinType::kFrexpResultVec2F16;
    }
    if (str == "__frexp_result_vec2_f32") {
        return BuiltinType::kFrexpResultVec2F32;
    }
    if (str == "__frexp_result_vec3_abstract") {
        return BuiltinType::kFrexpResultVec3Abstract;
    }
    if (str == "__frexp_result_vec3_f16") {
        return BuiltinType::kFrexpResultVec3F16;
    }
    if (str == "__frexp_result_vec3_f32") {
        return BuiltinType::kFrexpResultVec3F32;
    }
    if (str == "__frexp_result_vec4_abstract") {
        return BuiltinType::kFrexpResultVec4Abstract;
    }
    if (str == "__frexp_result_vec4_f16") {
        return BuiltinType::kFrexpResultVec4F16;
    }
    if (str == "__frexp_result_vec4_f32") {
        return BuiltinType::kFrexpResultVec4F32;
    }
    if (str == "__modf_result_abstract") {
        return BuiltinType::kModfResultAbstract;
    }
    if (str == "__modf_result_f16") {
        return BuiltinType::kModfResultF16;
    }
    if (str == "__modf_result_f32") {
        return BuiltinType::kModfResultF32;
    }
    if (str == "__modf_result_vec2_abstract") {
        return BuiltinType::kModfResultVec2Abstract;
    }
    if (str == "__modf_result_vec2_f16") {
        return BuiltinType::kModfResultVec2F16;
    }
    if (str == "__modf_result_vec2_f32") {
        return BuiltinType::kModfResultVec2F32;
    }
    if (str == "__modf_result_vec3_abstract") {
        return BuiltinType::kModfResultVec3Abstract;
    }
    if (str == "__modf_result_vec3_f16") {
        return BuiltinType::kModfResultVec3F16;
    }
    if (str == "__modf_result_vec3_f32") {
        return BuiltinType::kModfResultVec3F32;
    }
    if (str == "__modf_result_vec4_abstract") {
        return BuiltinType::kModfResultVec4Abstract;
    }
    if (str == "__modf_result_vec4_f16") {
        return BuiltinType::kModfResultVec4F16;
    }
    if (str == "__modf_result_vec4_f32") {
        return BuiltinType::kModfResultVec4F32;
    }
    if (str == "array") {
        return BuiltinType::kArray;
    }
    if (str == "atomic") {
        return BuiltinType::kAtomic;
    }
    if (str == "binding_array") {
        return BuiltinType::kBindingArray;
    }
    if (str == "bool") {
        return BuiltinType::kBool;
    }
    if (str == "f16") {
        return BuiltinType::kF16;
    }
    if (str == "f32") {
        return BuiltinType::kF32;
    }
    if (str == "i32") {
        return BuiltinType::kI32;
    }
    if (str == "i8") {
        return BuiltinType::kI8;
    }
    if (str == "input_attachment") {
        return BuiltinType::kInputAttachment;
    }
    if (str == "mat2x2") {
        return BuiltinType::kMat2X2;
    }
    if (str == "mat2x2f") {
        return BuiltinType::kMat2X2F;
    }
    if (str == "mat2x2h") {
        return BuiltinType::kMat2X2H;
    }
    if (str == "mat2x3") {
        return BuiltinType::kMat2X3;
    }
    if (str == "mat2x3f") {
        return BuiltinType::kMat2X3F;
    }
    if (str == "mat2x3h") {
        return BuiltinType::kMat2X3H;
    }
    if (str == "mat2x4") {
        return BuiltinType::kMat2X4;
    }
    if (str == "mat2x4f") {
        return BuiltinType::kMat2X4F;
    }
    if (str == "mat2x4h") {
        return BuiltinType::kMat2X4H;
    }
    if (str == "mat3x2") {
        return BuiltinType::kMat3X2;
    }
    if (str == "mat3x2f") {
        return BuiltinType::kMat3X2F;
    }
    if (str == "mat3x2h") {
        return BuiltinType::kMat3X2H;
    }
    if (str == "mat3x3") {
        return BuiltinType::kMat3X3;
    }
    if (str == "mat3x3f") {
        return BuiltinType::kMat3X3F;
    }
    if (str == "mat3x3h") {
        return BuiltinType::kMat3X3H;
    }
    if (str == "mat3x4") {
        return BuiltinType::kMat3X4;
    }
    if (str == "mat3x4f") {
        return BuiltinType::kMat3X4F;
    }
    if (str == "mat3x4h") {
        return BuiltinType::kMat3X4H;
    }
    if (str == "mat4x2") {
        return BuiltinType::kMat4X2;
    }
    if (str == "mat4x2f") {
        return BuiltinType::kMat4X2F;
    }
    if (str == "mat4x2h") {
        return BuiltinType::kMat4X2H;
    }
    if (str == "mat4x3") {
        return BuiltinType::kMat4X3;
    }
    if (str == "mat4x3f") {
        return BuiltinType::kMat4X3F;
    }
    if (str == "mat4x3h") {
        return BuiltinType::kMat4X3H;
    }
    if (str == "mat4x4") {
        return BuiltinType::kMat4X4;
    }
    if (str == "mat4x4f") {
        return BuiltinType::kMat4X4F;
    }
    if (str == "mat4x4h") {
        return BuiltinType::kMat4X4H;
    }
    if (str == "ptr") {
        return BuiltinType::kPtr;
    }
    if (str == "sampler") {
        return BuiltinType::kSampler;
    }
    if (str == "sampler_comparison") {
        return BuiltinType::kSamplerComparison;
    }
    if (str == "subgroup_matrix_left") {
        return BuiltinType::kSubgroupMatrixLeft;
    }
    if (str == "subgroup_matrix_result") {
        return BuiltinType::kSubgroupMatrixResult;
    }
    if (str == "subgroup_matrix_right") {
        return BuiltinType::kSubgroupMatrixRight;
    }
    if (str == "texel_buffer") {
        return BuiltinType::kTexelBuffer;
    }
    if (str == "texture_1d") {
        return BuiltinType::kTexture1D;
    }
    if (str == "texture_2d") {
        return BuiltinType::kTexture2D;
    }
    if (str == "texture_2d_array") {
        return BuiltinType::kTexture2DArray;
    }
    if (str == "texture_3d") {
        return BuiltinType::kTexture3D;
    }
    if (str == "texture_cube") {
        return BuiltinType::kTextureCube;
    }
    if (str == "texture_cube_array") {
        return BuiltinType::kTextureCubeArray;
    }
    if (str == "texture_depth_2d") {
        return BuiltinType::kTextureDepth2D;
    }
    if (str == "texture_depth_2d_array") {
        return BuiltinType::kTextureDepth2DArray;
    }
    if (str == "texture_depth_cube") {
        return BuiltinType::kTextureDepthCube;
    }
    if (str == "texture_depth_cube_array") {
        return BuiltinType::kTextureDepthCubeArray;
    }
    if (str == "texture_depth_multisampled_2d") {
        return BuiltinType::kTextureDepthMultisampled2D;
    }
    if (str == "texture_external") {
        return BuiltinType::kTextureExternal;
    }
    if (str == "texture_multisampled_2d") {
        return BuiltinType::kTextureMultisampled2D;
    }
    if (str == "texture_storage_1d") {
        return BuiltinType::kTextureStorage1D;
    }
    if (str == "texture_storage_2d") {
        return BuiltinType::kTextureStorage2D;
    }
    if (str == "texture_storage_2d_array") {
        return BuiltinType::kTextureStorage2DArray;
    }
    if (str == "texture_storage_3d") {
        return BuiltinType::kTextureStorage3D;
    }
    if (str == "u32") {
        return BuiltinType::kU32;
    }
    if (str == "u8") {
        return BuiltinType::kU8;
    }
    if (str == "vec2") {
        return BuiltinType::kVec2;
    }
    if (str == "vec2f") {
        return BuiltinType::kVec2F;
    }
    if (str == "vec2h") {
        return BuiltinType::kVec2H;
    }
    if (str == "vec2i") {
        return BuiltinType::kVec2I;
    }
    if (str == "vec2u") {
        return BuiltinType::kVec2U;
    }
    if (str == "vec3") {
        return BuiltinType::kVec3;
    }
    if (str == "vec3f") {
        return BuiltinType::kVec3F;
    }
    if (str == "vec3h") {
        return BuiltinType::kVec3H;
    }
    if (str == "vec3i") {
        return BuiltinType::kVec3I;
    }
    if (str == "vec3u") {
        return BuiltinType::kVec3U;
    }
    if (str == "vec4") {
        return BuiltinType::kVec4;
    }
    if (str == "vec4f") {
        return BuiltinType::kVec4F;
    }
    if (str == "vec4h") {
        return BuiltinType::kVec4H;
    }
    if (str == "vec4i") {
        return BuiltinType::kVec4I;
    }
    if (str == "vec4u") {
        return BuiltinType::kVec4U;
    }
    return BuiltinType::kUndefined;
}
std::string_view ToString(BuiltinType value) {
    switch (value) {
        case BuiltinType::kUndefined:
            return "undefined";
        case BuiltinType::kAtomicCompareExchangeResultI32:
            return "__atomic_compare_exchange_result_i32";
        case BuiltinType::kAtomicCompareExchangeResultU32:
            return "__atomic_compare_exchange_result_u32";
        case BuiltinType::kFrexpResultAbstract:
            return "__frexp_result_abstract";
        case BuiltinType::kFrexpResultF16:
            return "__frexp_result_f16";
        case BuiltinType::kFrexpResultF32:
            return "__frexp_result_f32";
        case BuiltinType::kFrexpResultVec2Abstract:
            return "__frexp_result_vec2_abstract";
        case BuiltinType::kFrexpResultVec2F16:
            return "__frexp_result_vec2_f16";
        case BuiltinType::kFrexpResultVec2F32:
            return "__frexp_result_vec2_f32";
        case BuiltinType::kFrexpResultVec3Abstract:
            return "__frexp_result_vec3_abstract";
        case BuiltinType::kFrexpResultVec3F16:
            return "__frexp_result_vec3_f16";
        case BuiltinType::kFrexpResultVec3F32:
            return "__frexp_result_vec3_f32";
        case BuiltinType::kFrexpResultVec4Abstract:
            return "__frexp_result_vec4_abstract";
        case BuiltinType::kFrexpResultVec4F16:
            return "__frexp_result_vec4_f16";
        case BuiltinType::kFrexpResultVec4F32:
            return "__frexp_result_vec4_f32";
        case BuiltinType::kModfResultAbstract:
            return "__modf_result_abstract";
        case BuiltinType::kModfResultF16:
            return "__modf_result_f16";
        case BuiltinType::kModfResultF32:
            return "__modf_result_f32";
        case BuiltinType::kModfResultVec2Abstract:
            return "__modf_result_vec2_abstract";
        case BuiltinType::kModfResultVec2F16:
            return "__modf_result_vec2_f16";
        case BuiltinType::kModfResultVec2F32:
            return "__modf_result_vec2_f32";
        case BuiltinType::kModfResultVec3Abstract:
            return "__modf_result_vec3_abstract";
        case BuiltinType::kModfResultVec3F16:
            return "__modf_result_vec3_f16";
        case BuiltinType::kModfResultVec3F32:
            return "__modf_result_vec3_f32";
        case BuiltinType::kModfResultVec4Abstract:
            return "__modf_result_vec4_abstract";
        case BuiltinType::kModfResultVec4F16:
            return "__modf_result_vec4_f16";
        case BuiltinType::kModfResultVec4F32:
            return "__modf_result_vec4_f32";
        case BuiltinType::kArray:
            return "array";
        case BuiltinType::kAtomic:
            return "atomic";
        case BuiltinType::kBindingArray:
            return "binding_array";
        case BuiltinType::kBool:
            return "bool";
        case BuiltinType::kF16:
            return "f16";
        case BuiltinType::kF32:
            return "f32";
        case BuiltinType::kI32:
            return "i32";
        case BuiltinType::kI8:
            return "i8";
        case BuiltinType::kInputAttachment:
            return "input_attachment";
        case BuiltinType::kMat2X2:
            return "mat2x2";
        case BuiltinType::kMat2X2F:
            return "mat2x2f";
        case BuiltinType::kMat2X2H:
            return "mat2x2h";
        case BuiltinType::kMat2X3:
            return "mat2x3";
        case BuiltinType::kMat2X3F:
            return "mat2x3f";
        case BuiltinType::kMat2X3H:
            return "mat2x3h";
        case BuiltinType::kMat2X4:
            return "mat2x4";
        case BuiltinType::kMat2X4F:
            return "mat2x4f";
        case BuiltinType::kMat2X4H:
            return "mat2x4h";
        case BuiltinType::kMat3X2:
            return "mat3x2";
        case BuiltinType::kMat3X2F:
            return "mat3x2f";
        case BuiltinType::kMat3X2H:
            return "mat3x2h";
        case BuiltinType::kMat3X3:
            return "mat3x3";
        case BuiltinType::kMat3X3F:
            return "mat3x3f";
        case BuiltinType::kMat3X3H:
            return "mat3x3h";
        case BuiltinType::kMat3X4:
            return "mat3x4";
        case BuiltinType::kMat3X4F:
            return "mat3x4f";
        case BuiltinType::kMat3X4H:
            return "mat3x4h";
        case BuiltinType::kMat4X2:
            return "mat4x2";
        case BuiltinType::kMat4X2F:
            return "mat4x2f";
        case BuiltinType::kMat4X2H:
            return "mat4x2h";
        case BuiltinType::kMat4X3:
            return "mat4x3";
        case BuiltinType::kMat4X3F:
            return "mat4x3f";
        case BuiltinType::kMat4X3H:
            return "mat4x3h";
        case BuiltinType::kMat4X4:
            return "mat4x4";
        case BuiltinType::kMat4X4F:
            return "mat4x4f";
        case BuiltinType::kMat4X4H:
            return "mat4x4h";
        case BuiltinType::kPtr:
            return "ptr";
        case BuiltinType::kSampler:
            return "sampler";
        case BuiltinType::kSamplerComparison:
            return "sampler_comparison";
        case BuiltinType::kSubgroupMatrixLeft:
            return "subgroup_matrix_left";
        case BuiltinType::kSubgroupMatrixResult:
            return "subgroup_matrix_result";
        case BuiltinType::kSubgroupMatrixRight:
            return "subgroup_matrix_right";
        case BuiltinType::kTexelBuffer:
            return "texel_buffer";
        case BuiltinType::kTexture1D:
            return "texture_1d";
        case BuiltinType::kTexture2D:
            return "texture_2d";
        case BuiltinType::kTexture2DArray:
            return "texture_2d_array";
        case BuiltinType::kTexture3D:
            return "texture_3d";
        case BuiltinType::kTextureCube:
            return "texture_cube";
        case BuiltinType::kTextureCubeArray:
            return "texture_cube_array";
        case BuiltinType::kTextureDepth2D:
            return "texture_depth_2d";
        case BuiltinType::kTextureDepth2DArray:
            return "texture_depth_2d_array";
        case BuiltinType::kTextureDepthCube:
            return "texture_depth_cube";
        case BuiltinType::kTextureDepthCubeArray:
            return "texture_depth_cube_array";
        case BuiltinType::kTextureDepthMultisampled2D:
            return "texture_depth_multisampled_2d";
        case BuiltinType::kTextureExternal:
            return "texture_external";
        case BuiltinType::kTextureMultisampled2D:
            return "texture_multisampled_2d";
        case BuiltinType::kTextureStorage1D:
            return "texture_storage_1d";
        case BuiltinType::kTextureStorage2D:
            return "texture_storage_2d";
        case BuiltinType::kTextureStorage2DArray:
            return "texture_storage_2d_array";
        case BuiltinType::kTextureStorage3D:
            return "texture_storage_3d";
        case BuiltinType::kU32:
            return "u32";
        case BuiltinType::kU8:
            return "u8";
        case BuiltinType::kVec2:
            return "vec2";
        case BuiltinType::kVec2F:
            return "vec2f";
        case BuiltinType::kVec2H:
            return "vec2h";
        case BuiltinType::kVec2I:
            return "vec2i";
        case BuiltinType::kVec2U:
            return "vec2u";
        case BuiltinType::kVec3:
            return "vec3";
        case BuiltinType::kVec3F:
            return "vec3f";
        case BuiltinType::kVec3H:
            return "vec3h";
        case BuiltinType::kVec3I:
            return "vec3i";
        case BuiltinType::kVec3U:
            return "vec3u";
        case BuiltinType::kVec4:
            return "vec4";
        case BuiltinType::kVec4F:
            return "vec4f";
        case BuiltinType::kVec4H:
            return "vec4h";
        case BuiltinType::kVec4I:
            return "vec4i";
        case BuiltinType::kVec4U:
            return "vec4u";
    }
    return "<unknown>";
}

/// ParseBuiltinValue parses a BuiltinValue from a string.
/// @param str the string to parse
/// @returns the parsed enum, or BuiltinValue::kUndefined if the string could not be parsed.
BuiltinValue ParseBuiltinValue(std::string_view str) {
    if (str == "barycentric_coord") {
        return BuiltinValue::kBarycentricCoord;
    }
    if (str == "clip_distances") {
        return BuiltinValue::kClipDistances;
    }
    if (str == "frag_depth") {
        return BuiltinValue::kFragDepth;
    }
    if (str == "front_facing") {
        return BuiltinValue::kFrontFacing;
    }
    if (str == "global_invocation_id") {
        return BuiltinValue::kGlobalInvocationId;
    }
    if (str == "instance_index") {
        return BuiltinValue::kInstanceIndex;
    }
    if (str == "local_invocation_id") {
        return BuiltinValue::kLocalInvocationId;
    }
    if (str == "local_invocation_index") {
        return BuiltinValue::kLocalInvocationIndex;
    }
    if (str == "num_workgroups") {
        return BuiltinValue::kNumWorkgroups;
    }
    if (str == "position") {
        return BuiltinValue::kPosition;
    }
    if (str == "primitive_id") {
        return BuiltinValue::kPrimitiveId;
    }
    if (str == "sample_index") {
        return BuiltinValue::kSampleIndex;
    }
    if (str == "sample_mask") {
        return BuiltinValue::kSampleMask;
    }
    if (str == "subgroup_id") {
        return BuiltinValue::kSubgroupId;
    }
    if (str == "subgroup_invocation_id") {
        return BuiltinValue::kSubgroupInvocationId;
    }
    if (str == "subgroup_size") {
        return BuiltinValue::kSubgroupSize;
    }
    if (str == "vertex_index") {
        return BuiltinValue::kVertexIndex;
    }
    if (str == "workgroup_id") {
        return BuiltinValue::kWorkgroupId;
    }
    return BuiltinValue::kUndefined;
}
std::string_view ToString(BuiltinValue value) {
    switch (value) {
        case BuiltinValue::kUndefined:
            return "undefined";
        case BuiltinValue::kCullDistance:
            return "__cull_distance";
        case BuiltinValue::kPointSize:
            return "__point_size";
        case BuiltinValue::kBarycentricCoord:
            return "barycentric_coord";
        case BuiltinValue::kClipDistances:
            return "clip_distances";
        case BuiltinValue::kFragDepth:
            return "frag_depth";
        case BuiltinValue::kFrontFacing:
            return "front_facing";
        case BuiltinValue::kGlobalInvocationId:
            return "global_invocation_id";
        case BuiltinValue::kInstanceIndex:
            return "instance_index";
        case BuiltinValue::kLocalInvocationId:
            return "local_invocation_id";
        case BuiltinValue::kLocalInvocationIndex:
            return "local_invocation_index";
        case BuiltinValue::kNumWorkgroups:
            return "num_workgroups";
        case BuiltinValue::kPosition:
            return "position";
        case BuiltinValue::kPrimitiveId:
            return "primitive_id";
        case BuiltinValue::kSampleIndex:
            return "sample_index";
        case BuiltinValue::kSampleMask:
            return "sample_mask";
        case BuiltinValue::kSubgroupId:
            return "subgroup_id";
        case BuiltinValue::kSubgroupInvocationId:
            return "subgroup_invocation_id";
        case BuiltinValue::kSubgroupSize:
            return "subgroup_size";
        case BuiltinValue::kVertexIndex:
            return "vertex_index";
        case BuiltinValue::kWorkgroupId:
            return "workgroup_id";
    }
    return "<unknown>";
}

/// ParseAttribute parses a Attribute from a string.
/// @param str the string to parse
/// @returns the parsed enum, or Attribute::kUndefined if the string could not be parsed.
Attribute ParseAttribute(std::string_view str) {
    if (str == "align") {
        return Attribute::kAlign;
    }
    if (str == "binding") {
        return Attribute::kBinding;
    }
    if (str == "blend_src") {
        return Attribute::kBlendSrc;
    }
    if (str == "builtin") {
        return Attribute::kBuiltin;
    }
    if (str == "color") {
        return Attribute::kColor;
    }
    if (str == "compute") {
        return Attribute::kCompute;
    }
    if (str == "diagnostic") {
        return Attribute::kDiagnostic;
    }
    if (str == "fragment") {
        return Attribute::kFragment;
    }
    if (str == "group") {
        return Attribute::kGroup;
    }
    if (str == "id") {
        return Attribute::kId;
    }
    if (str == "input_attachment_index") {
        return Attribute::kInputAttachmentIndex;
    }
    if (str == "interpolate") {
        return Attribute::kInterpolate;
    }
    if (str == "invariant") {
        return Attribute::kInvariant;
    }
    if (str == "location") {
        return Attribute::kLocation;
    }
    if (str == "must_use") {
        return Attribute::kMustUse;
    }
    if (str == "size") {
        return Attribute::kSize;
    }
    if (str == "vertex") {
        return Attribute::kVertex;
    }
    if (str == "workgroup_size") {
        return Attribute::kWorkgroupSize;
    }
    return Attribute::kUndefined;
}
std::string_view ToString(Attribute value) {
    switch (value) {
        case Attribute::kUndefined:
            return "undefined";
        case Attribute::kAlign:
            return "align";
        case Attribute::kBinding:
            return "binding";
        case Attribute::kBlendSrc:
            return "blend_src";
        case Attribute::kBuiltin:
            return "builtin";
        case Attribute::kColor:
            return "color";
        case Attribute::kCompute:
            return "compute";
        case Attribute::kDiagnostic:
            return "diagnostic";
        case Attribute::kFragment:
            return "fragment";
        case Attribute::kGroup:
            return "group";
        case Attribute::kId:
            return "id";
        case Attribute::kInputAttachmentIndex:
            return "input_attachment_index";
        case Attribute::kInterpolate:
            return "interpolate";
        case Attribute::kInvariant:
            return "invariant";
        case Attribute::kLocation:
            return "location";
        case Attribute::kMustUse:
            return "must_use";
        case Attribute::kSize:
            return "size";
        case Attribute::kVertex:
            return "vertex";
        case Attribute::kWorkgroupSize:
            return "workgroup_size";
    }
    return "<unknown>";
}

std::string_view ToString(ParameterUsage usage) {
    switch (usage) {
        case ParameterUsage::kNone:
            return "none";
        case ParameterUsage::kArrayIndex:
            return "array_index";
        case ParameterUsage::kBase:
            return "base";
        case ParameterUsage::kBias:
            return "bias";
        case ParameterUsage::kBits:
            return "bits";
        case ParameterUsage::kCompareValue:
            return "compare_value";
        case ParameterUsage::kComponent:
            return "component";
        case ParameterUsage::kConstOffset:
            return "const_offset";
        case ParameterUsage::kCoords:
            return "coords";
        case ParameterUsage::kCount:
            return "count";
        case ParameterUsage::kDdx:
            return "ddx";
        case ParameterUsage::kDdy:
            return "ddy";
        case ParameterUsage::kDelta:
            return "delta";
        case ParameterUsage::kDepth:
            return "depth";
        case ParameterUsage::kDepthRef:
            return "depth_ref";
        case ParameterUsage::kDir:
            return "dir";
        case ParameterUsage::kDref:
            return "dref";
        case ParameterUsage::kE:
            return "e";
        case ParameterUsage::kElements:
            return "elements";
        case ParameterUsage::kExp:
            return "exp";
        case ParameterUsage::kGroupOperation:
            return "group_operation";
        case ParameterUsage::kHeight:
            return "height";
        case ParameterUsage::kI:
            return "i";
        case ParameterUsage::kId:
            return "id";
        case ParameterUsage::kImage:
            return "image";
        case ParameterUsage::kImageOperands:
            return "image_operands";
        case ParameterUsage::kInputAttachment:
            return "input_attachment";
        case ParameterUsage::kInsert:
            return "insert";
        case ParameterUsage::kLevel:
            return "level";
        case ParameterUsage::kLocation:
            return "location";
        case ParameterUsage::kLod:
            return "lod";
        case ParameterUsage::kMask:
            return "mask";
        case ParameterUsage::kNumLevels:
            return "num_levels";
        case ParameterUsage::kOffset:
            return "offset";
        case ParameterUsage::kOriginalValue:
            return "original_value";
        case ParameterUsage::kRefz:
            return "refz";
        case ParameterUsage::kResult:
            return "result";
        case ParameterUsage::kSample:
            return "sample";
        case ParameterUsage::kSampleIndex:
            return "sample_index";
        case ParameterUsage::kSampler:
            return "sampler";
        case ParameterUsage::kSamples:
            return "samples";
        case ParameterUsage::kScope:
            return "scope";
        case ParameterUsage::kSourceLaneIndex:
            return "sourceLaneIndex";
        case ParameterUsage::kTexel:
            return "texel";
        case ParameterUsage::kTexture:
            return "texture";
        case ParameterUsage::kValue:
            return "value";
        case ParameterUsage::kW:
            return "w";
        case ParameterUsage::kWidth:
            return "width";
        case ParameterUsage::kX:
            return "x";
        case ParameterUsage::kXy:
            return "xy";
        case ParameterUsage::kXyz:
            return "xyz";
        case ParameterUsage::kY:
            return "y";
        case ParameterUsage::kYz:
            return "yz";
        case ParameterUsage::kZ:
            return "z";
        case ParameterUsage::kZw:
            return "zw";
        case ParameterUsage::kZyw:
            return "zyw";
    }
    return "<unknown>";
}

BuiltinFn ParseBuiltinFn(std::string_view name) {
    if (name == "abs") {
        return BuiltinFn::kAbs;
    }
    if (name == "acos") {
        return BuiltinFn::kAcos;
    }
    if (name == "acosh") {
        return BuiltinFn::kAcosh;
    }
    if (name == "all") {
        return BuiltinFn::kAll;
    }
    if (name == "any") {
        return BuiltinFn::kAny;
    }
    if (name == "arrayLength") {
        return BuiltinFn::kArrayLength;
    }
    if (name == "asin") {
        return BuiltinFn::kAsin;
    }
    if (name == "asinh") {
        return BuiltinFn::kAsinh;
    }
    if (name == "atan") {
        return BuiltinFn::kAtan;
    }
    if (name == "atan2") {
        return BuiltinFn::kAtan2;
    }
    if (name == "atanh") {
        return BuiltinFn::kAtanh;
    }
    if (name == "ceil") {
        return BuiltinFn::kCeil;
    }
    if (name == "clamp") {
        return BuiltinFn::kClamp;
    }
    if (name == "cos") {
        return BuiltinFn::kCos;
    }
    if (name == "cosh") {
        return BuiltinFn::kCosh;
    }
    if (name == "countLeadingZeros") {
        return BuiltinFn::kCountLeadingZeros;
    }
    if (name == "countOneBits") {
        return BuiltinFn::kCountOneBits;
    }
    if (name == "countTrailingZeros") {
        return BuiltinFn::kCountTrailingZeros;
    }
    if (name == "cross") {
        return BuiltinFn::kCross;
    }
    if (name == "degrees") {
        return BuiltinFn::kDegrees;
    }
    if (name == "determinant") {
        return BuiltinFn::kDeterminant;
    }
    if (name == "distance") {
        return BuiltinFn::kDistance;
    }
    if (name == "dot") {
        return BuiltinFn::kDot;
    }
    if (name == "dot4I8Packed") {
        return BuiltinFn::kDot4I8Packed;
    }
    if (name == "dot4U8Packed") {
        return BuiltinFn::kDot4U8Packed;
    }
    if (name == "dpdx") {
        return BuiltinFn::kDpdx;
    }
    if (name == "dpdxCoarse") {
        return BuiltinFn::kDpdxCoarse;
    }
    if (name == "dpdxFine") {
        return BuiltinFn::kDpdxFine;
    }
    if (name == "dpdy") {
        return BuiltinFn::kDpdy;
    }
    if (name == "dpdyCoarse") {
        return BuiltinFn::kDpdyCoarse;
    }
    if (name == "dpdyFine") {
        return BuiltinFn::kDpdyFine;
    }
    if (name == "exp") {
        return BuiltinFn::kExp;
    }
    if (name == "exp2") {
        return BuiltinFn::kExp2;
    }
    if (name == "extractBits") {
        return BuiltinFn::kExtractBits;
    }
    if (name == "faceForward") {
        return BuiltinFn::kFaceForward;
    }
    if (name == "firstLeadingBit") {
        return BuiltinFn::kFirstLeadingBit;
    }
    if (name == "firstTrailingBit") {
        return BuiltinFn::kFirstTrailingBit;
    }
    if (name == "floor") {
        return BuiltinFn::kFloor;
    }
    if (name == "fma") {
        return BuiltinFn::kFma;
    }
    if (name == "fract") {
        return BuiltinFn::kFract;
    }
    if (name == "frexp") {
        return BuiltinFn::kFrexp;
    }
    if (name == "fwidth") {
        return BuiltinFn::kFwidth;
    }
    if (name == "fwidthCoarse") {
        return BuiltinFn::kFwidthCoarse;
    }
    if (name == "fwidthFine") {
        return BuiltinFn::kFwidthFine;
    }
    if (name == "insertBits") {
        return BuiltinFn::kInsertBits;
    }
    if (name == "inverseSqrt") {
        return BuiltinFn::kInverseSqrt;
    }
    if (name == "ldexp") {
        return BuiltinFn::kLdexp;
    }
    if (name == "length") {
        return BuiltinFn::kLength;
    }
    if (name == "log") {
        return BuiltinFn::kLog;
    }
    if (name == "log2") {
        return BuiltinFn::kLog2;
    }
    if (name == "max") {
        return BuiltinFn::kMax;
    }
    if (name == "min") {
        return BuiltinFn::kMin;
    }
    if (name == "mix") {
        return BuiltinFn::kMix;
    }
    if (name == "modf") {
        return BuiltinFn::kModf;
    }
    if (name == "normalize") {
        return BuiltinFn::kNormalize;
    }
    if (name == "pack2x16float") {
        return BuiltinFn::kPack2X16Float;
    }
    if (name == "pack2x16snorm") {
        return BuiltinFn::kPack2X16Snorm;
    }
    if (name == "pack2x16unorm") {
        return BuiltinFn::kPack2X16Unorm;
    }
    if (name == "pack4x8snorm") {
        return BuiltinFn::kPack4X8Snorm;
    }
    if (name == "pack4x8unorm") {
        return BuiltinFn::kPack4X8Unorm;
    }
    if (name == "pack4xI8") {
        return BuiltinFn::kPack4XI8;
    }
    if (name == "pack4xU8") {
        return BuiltinFn::kPack4XU8;
    }
    if (name == "pack4xI8Clamp") {
        return BuiltinFn::kPack4XI8Clamp;
    }
    if (name == "pack4xU8Clamp") {
        return BuiltinFn::kPack4XU8Clamp;
    }
    if (name == "pow") {
        return BuiltinFn::kPow;
    }
    if (name == "quantizeToF16") {
        return BuiltinFn::kQuantizeToF16;
    }
    if (name == "radians") {
        return BuiltinFn::kRadians;
    }
    if (name == "reflect") {
        return BuiltinFn::kReflect;
    }
    if (name == "refract") {
        return BuiltinFn::kRefract;
    }
    if (name == "reverseBits") {
        return BuiltinFn::kReverseBits;
    }
    if (name == "round") {
        return BuiltinFn::kRound;
    }
    if (name == "saturate") {
        return BuiltinFn::kSaturate;
    }
    if (name == "select") {
        return BuiltinFn::kSelect;
    }
    if (name == "sign") {
        return BuiltinFn::kSign;
    }
    if (name == "sin") {
        return BuiltinFn::kSin;
    }
    if (name == "sinh") {
        return BuiltinFn::kSinh;
    }
    if (name == "smoothstep") {
        return BuiltinFn::kSmoothstep;
    }
    if (name == "sqrt") {
        return BuiltinFn::kSqrt;
    }
    if (name == "step") {
        return BuiltinFn::kStep;
    }
    if (name == "storageBarrier") {
        return BuiltinFn::kStorageBarrier;
    }
    if (name == "tan") {
        return BuiltinFn::kTan;
    }
    if (name == "tanh") {
        return BuiltinFn::kTanh;
    }
    if (name == "transpose") {
        return BuiltinFn::kTranspose;
    }
    if (name == "trunc") {
        return BuiltinFn::kTrunc;
    }
    if (name == "unpack2x16float") {
        return BuiltinFn::kUnpack2X16Float;
    }
    if (name == "unpack2x16snorm") {
        return BuiltinFn::kUnpack2X16Snorm;
    }
    if (name == "unpack2x16unorm") {
        return BuiltinFn::kUnpack2X16Unorm;
    }
    if (name == "unpack4x8snorm") {
        return BuiltinFn::kUnpack4X8Snorm;
    }
    if (name == "unpack4x8unorm") {
        return BuiltinFn::kUnpack4X8Unorm;
    }
    if (name == "unpack4xI8") {
        return BuiltinFn::kUnpack4XI8;
    }
    if (name == "unpack4xU8") {
        return BuiltinFn::kUnpack4XU8;
    }
    if (name == "workgroupBarrier") {
        return BuiltinFn::kWorkgroupBarrier;
    }
    if (name == "textureBarrier") {
        return BuiltinFn::kTextureBarrier;
    }
    if (name == "textureDimensions") {
        return BuiltinFn::kTextureDimensions;
    }
    if (name == "textureGather") {
        return BuiltinFn::kTextureGather;
    }
    if (name == "textureGatherCompare") {
        return BuiltinFn::kTextureGatherCompare;
    }
    if (name == "textureNumLayers") {
        return BuiltinFn::kTextureNumLayers;
    }
    if (name == "textureNumLevels") {
        return BuiltinFn::kTextureNumLevels;
    }
    if (name == "textureNumSamples") {
        return BuiltinFn::kTextureNumSamples;
    }
    if (name == "textureSample") {
        return BuiltinFn::kTextureSample;
    }
    if (name == "textureSampleBias") {
        return BuiltinFn::kTextureSampleBias;
    }
    if (name == "textureSampleCompare") {
        return BuiltinFn::kTextureSampleCompare;
    }
    if (name == "textureSampleCompareLevel") {
        return BuiltinFn::kTextureSampleCompareLevel;
    }
    if (name == "textureSampleGrad") {
        return BuiltinFn::kTextureSampleGrad;
    }
    if (name == "textureSampleLevel") {
        return BuiltinFn::kTextureSampleLevel;
    }
    if (name == "textureSampleBaseClampToEdge") {
        return BuiltinFn::kTextureSampleBaseClampToEdge;
    }
    if (name == "textureStore") {
        return BuiltinFn::kTextureStore;
    }
    if (name == "textureLoad") {
        return BuiltinFn::kTextureLoad;
    }
    if (name == "inputAttachmentLoad") {
        return BuiltinFn::kInputAttachmentLoad;
    }
    if (name == "atomicLoad") {
        return BuiltinFn::kAtomicLoad;
    }
    if (name == "atomicStore") {
        return BuiltinFn::kAtomicStore;
    }
    if (name == "atomicAdd") {
        return BuiltinFn::kAtomicAdd;
    }
    if (name == "atomicSub") {
        return BuiltinFn::kAtomicSub;
    }
    if (name == "atomicMax") {
        return BuiltinFn::kAtomicMax;
    }
    if (name == "atomicMin") {
        return BuiltinFn::kAtomicMin;
    }
    if (name == "atomicAnd") {
        return BuiltinFn::kAtomicAnd;
    }
    if (name == "atomicOr") {
        return BuiltinFn::kAtomicOr;
    }
    if (name == "atomicXor") {
        return BuiltinFn::kAtomicXor;
    }
    if (name == "atomicExchange") {
        return BuiltinFn::kAtomicExchange;
    }
    if (name == "atomicCompareExchangeWeak") {
        return BuiltinFn::kAtomicCompareExchangeWeak;
    }
    if (name == "subgroupBallot") {
        return BuiltinFn::kSubgroupBallot;
    }
    if (name == "subgroupElect") {
        return BuiltinFn::kSubgroupElect;
    }
    if (name == "subgroupBroadcast") {
        return BuiltinFn::kSubgroupBroadcast;
    }
    if (name == "subgroupBroadcastFirst") {
        return BuiltinFn::kSubgroupBroadcastFirst;
    }
    if (name == "subgroupShuffle") {
        return BuiltinFn::kSubgroupShuffle;
    }
    if (name == "subgroupShuffleXor") {
        return BuiltinFn::kSubgroupShuffleXor;
    }
    if (name == "subgroupShuffleUp") {
        return BuiltinFn::kSubgroupShuffleUp;
    }
    if (name == "subgroupShuffleDown") {
        return BuiltinFn::kSubgroupShuffleDown;
    }
    if (name == "subgroupAdd") {
        return BuiltinFn::kSubgroupAdd;
    }
    if (name == "subgroupInclusiveAdd") {
        return BuiltinFn::kSubgroupInclusiveAdd;
    }
    if (name == "subgroupExclusiveAdd") {
        return BuiltinFn::kSubgroupExclusiveAdd;
    }
    if (name == "subgroupMul") {
        return BuiltinFn::kSubgroupMul;
    }
    if (name == "subgroupInclusiveMul") {
        return BuiltinFn::kSubgroupInclusiveMul;
    }
    if (name == "subgroupExclusiveMul") {
        return BuiltinFn::kSubgroupExclusiveMul;
    }
    if (name == "subgroupAnd") {
        return BuiltinFn::kSubgroupAnd;
    }
    if (name == "subgroupOr") {
        return BuiltinFn::kSubgroupOr;
    }
    if (name == "subgroupXor") {
        return BuiltinFn::kSubgroupXor;
    }
    if (name == "subgroupMin") {
        return BuiltinFn::kSubgroupMin;
    }
    if (name == "subgroupMax") {
        return BuiltinFn::kSubgroupMax;
    }
    if (name == "subgroupAll") {
        return BuiltinFn::kSubgroupAll;
    }
    if (name == "subgroupAny") {
        return BuiltinFn::kSubgroupAny;
    }
    if (name == "quadBroadcast") {
        return BuiltinFn::kQuadBroadcast;
    }
    if (name == "quadSwapX") {
        return BuiltinFn::kQuadSwapX;
    }
    if (name == "quadSwapY") {
        return BuiltinFn::kQuadSwapY;
    }
    if (name == "quadSwapDiagonal") {
        return BuiltinFn::kQuadSwapDiagonal;
    }
    if (name == "subgroupMatrixLoad") {
        return BuiltinFn::kSubgroupMatrixLoad;
    }
    if (name == "subgroupMatrixStore") {
        return BuiltinFn::kSubgroupMatrixStore;
    }
    if (name == "subgroupMatrixMultiply") {
        return BuiltinFn::kSubgroupMatrixMultiply;
    }
    if (name == "subgroupMatrixMultiplyAccumulate") {
        return BuiltinFn::kSubgroupMatrixMultiplyAccumulate;
    }
    if (name == "print") {
        return BuiltinFn::kPrint;
    }
    return BuiltinFn::kNone;
}

const char* str(BuiltinFn i) {
    switch (i) {
        case BuiltinFn::kNone:
            return "<none>";
        case BuiltinFn::kAbs:
            return "abs";
        case BuiltinFn::kAcos:
            return "acos";
        case BuiltinFn::kAcosh:
            return "acosh";
        case BuiltinFn::kAll:
            return "all";
        case BuiltinFn::kAny:
            return "any";
        case BuiltinFn::kArrayLength:
            return "arrayLength";
        case BuiltinFn::kAsin:
            return "asin";
        case BuiltinFn::kAsinh:
            return "asinh";
        case BuiltinFn::kAtan:
            return "atan";
        case BuiltinFn::kAtan2:
            return "atan2";
        case BuiltinFn::kAtanh:
            return "atanh";
        case BuiltinFn::kCeil:
            return "ceil";
        case BuiltinFn::kClamp:
            return "clamp";
        case BuiltinFn::kCos:
            return "cos";
        case BuiltinFn::kCosh:
            return "cosh";
        case BuiltinFn::kCountLeadingZeros:
            return "countLeadingZeros";
        case BuiltinFn::kCountOneBits:
            return "countOneBits";
        case BuiltinFn::kCountTrailingZeros:
            return "countTrailingZeros";
        case BuiltinFn::kCross:
            return "cross";
        case BuiltinFn::kDegrees:
            return "degrees";
        case BuiltinFn::kDeterminant:
            return "determinant";
        case BuiltinFn::kDistance:
            return "distance";
        case BuiltinFn::kDot:
            return "dot";
        case BuiltinFn::kDot4I8Packed:
            return "dot4I8Packed";
        case BuiltinFn::kDot4U8Packed:
            return "dot4U8Packed";
        case BuiltinFn::kDpdx:
            return "dpdx";
        case BuiltinFn::kDpdxCoarse:
            return "dpdxCoarse";
        case BuiltinFn::kDpdxFine:
            return "dpdxFine";
        case BuiltinFn::kDpdy:
            return "dpdy";
        case BuiltinFn::kDpdyCoarse:
            return "dpdyCoarse";
        case BuiltinFn::kDpdyFine:
            return "dpdyFine";
        case BuiltinFn::kExp:
            return "exp";
        case BuiltinFn::kExp2:
            return "exp2";
        case BuiltinFn::kExtractBits:
            return "extractBits";
        case BuiltinFn::kFaceForward:
            return "faceForward";
        case BuiltinFn::kFirstLeadingBit:
            return "firstLeadingBit";
        case BuiltinFn::kFirstTrailingBit:
            return "firstTrailingBit";
        case BuiltinFn::kFloor:
            return "floor";
        case BuiltinFn::kFma:
            return "fma";
        case BuiltinFn::kFract:
            return "fract";
        case BuiltinFn::kFrexp:
            return "frexp";
        case BuiltinFn::kFwidth:
            return "fwidth";
        case BuiltinFn::kFwidthCoarse:
            return "fwidthCoarse";
        case BuiltinFn::kFwidthFine:
            return "fwidthFine";
        case BuiltinFn::kInsertBits:
            return "insertBits";
        case BuiltinFn::kInverseSqrt:
            return "inverseSqrt";
        case BuiltinFn::kLdexp:
            return "ldexp";
        case BuiltinFn::kLength:
            return "length";
        case BuiltinFn::kLog:
            return "log";
        case BuiltinFn::kLog2:
            return "log2";
        case BuiltinFn::kMax:
            return "max";
        case BuiltinFn::kMin:
            return "min";
        case BuiltinFn::kMix:
            return "mix";
        case BuiltinFn::kModf:
            return "modf";
        case BuiltinFn::kNormalize:
            return "normalize";
        case BuiltinFn::kPack2X16Float:
            return "pack2x16float";
        case BuiltinFn::kPack2X16Snorm:
            return "pack2x16snorm";
        case BuiltinFn::kPack2X16Unorm:
            return "pack2x16unorm";
        case BuiltinFn::kPack4X8Snorm:
            return "pack4x8snorm";
        case BuiltinFn::kPack4X8Unorm:
            return "pack4x8unorm";
        case BuiltinFn::kPack4XI8:
            return "pack4xI8";
        case BuiltinFn::kPack4XU8:
            return "pack4xU8";
        case BuiltinFn::kPack4XI8Clamp:
            return "pack4xI8Clamp";
        case BuiltinFn::kPack4XU8Clamp:
            return "pack4xU8Clamp";
        case BuiltinFn::kPow:
            return "pow";
        case BuiltinFn::kQuantizeToF16:
            return "quantizeToF16";
        case BuiltinFn::kRadians:
            return "radians";
        case BuiltinFn::kReflect:
            return "reflect";
        case BuiltinFn::kRefract:
            return "refract";
        case BuiltinFn::kReverseBits:
            return "reverseBits";
        case BuiltinFn::kRound:
            return "round";
        case BuiltinFn::kSaturate:
            return "saturate";
        case BuiltinFn::kSelect:
            return "select";
        case BuiltinFn::kSign:
            return "sign";
        case BuiltinFn::kSin:
            return "sin";
        case BuiltinFn::kSinh:
            return "sinh";
        case BuiltinFn::kSmoothstep:
            return "smoothstep";
        case BuiltinFn::kSqrt:
            return "sqrt";
        case BuiltinFn::kStep:
            return "step";
        case BuiltinFn::kStorageBarrier:
            return "storageBarrier";
        case BuiltinFn::kTan:
            return "tan";
        case BuiltinFn::kTanh:
            return "tanh";
        case BuiltinFn::kTranspose:
            return "transpose";
        case BuiltinFn::kTrunc:
            return "trunc";
        case BuiltinFn::kUnpack2X16Float:
            return "unpack2x16float";
        case BuiltinFn::kUnpack2X16Snorm:
            return "unpack2x16snorm";
        case BuiltinFn::kUnpack2X16Unorm:
            return "unpack2x16unorm";
        case BuiltinFn::kUnpack4X8Snorm:
            return "unpack4x8snorm";
        case BuiltinFn::kUnpack4X8Unorm:
            return "unpack4x8unorm";
        case BuiltinFn::kUnpack4XI8:
            return "unpack4xI8";
        case BuiltinFn::kUnpack4XU8:
            return "unpack4xU8";
        case BuiltinFn::kWorkgroupBarrier:
            return "workgroupBarrier";
        case BuiltinFn::kTextureBarrier:
            return "textureBarrier";
        case BuiltinFn::kTextureDimensions:
            return "textureDimensions";
        case BuiltinFn::kTextureGather:
            return "textureGather";
        case BuiltinFn::kTextureGatherCompare:
            return "textureGatherCompare";
        case BuiltinFn::kTextureNumLayers:
            return "textureNumLayers";
        case BuiltinFn::kTextureNumLevels:
            return "textureNumLevels";
        case BuiltinFn::kTextureNumSamples:
            return "textureNumSamples";
        case BuiltinFn::kTextureSample:
            return "textureSample";
        case BuiltinFn::kTextureSampleBias:
            return "textureSampleBias";
        case BuiltinFn::kTextureSampleCompare:
            return "textureSampleCompare";
        case BuiltinFn::kTextureSampleCompareLevel:
            return "textureSampleCompareLevel";
        case BuiltinFn::kTextureSampleGrad:
            return "textureSampleGrad";
        case BuiltinFn::kTextureSampleLevel:
            return "textureSampleLevel";
        case BuiltinFn::kTextureSampleBaseClampToEdge:
            return "textureSampleBaseClampToEdge";
        case BuiltinFn::kTextureStore:
            return "textureStore";
        case BuiltinFn::kTextureLoad:
            return "textureLoad";
        case BuiltinFn::kInputAttachmentLoad:
            return "inputAttachmentLoad";
        case BuiltinFn::kAtomicLoad:
            return "atomicLoad";
        case BuiltinFn::kAtomicStore:
            return "atomicStore";
        case BuiltinFn::kAtomicAdd:
            return "atomicAdd";
        case BuiltinFn::kAtomicSub:
            return "atomicSub";
        case BuiltinFn::kAtomicMax:
            return "atomicMax";
        case BuiltinFn::kAtomicMin:
            return "atomicMin";
        case BuiltinFn::kAtomicAnd:
            return "atomicAnd";
        case BuiltinFn::kAtomicOr:
            return "atomicOr";
        case BuiltinFn::kAtomicXor:
            return "atomicXor";
        case BuiltinFn::kAtomicExchange:
            return "atomicExchange";
        case BuiltinFn::kAtomicCompareExchangeWeak:
            return "atomicCompareExchangeWeak";
        case BuiltinFn::kSubgroupBallot:
            return "subgroupBallot";
        case BuiltinFn::kSubgroupElect:
            return "subgroupElect";
        case BuiltinFn::kSubgroupBroadcast:
            return "subgroupBroadcast";
        case BuiltinFn::kSubgroupBroadcastFirst:
            return "subgroupBroadcastFirst";
        case BuiltinFn::kSubgroupShuffle:
            return "subgroupShuffle";
        case BuiltinFn::kSubgroupShuffleXor:
            return "subgroupShuffleXor";
        case BuiltinFn::kSubgroupShuffleUp:
            return "subgroupShuffleUp";
        case BuiltinFn::kSubgroupShuffleDown:
            return "subgroupShuffleDown";
        case BuiltinFn::kSubgroupAdd:
            return "subgroupAdd";
        case BuiltinFn::kSubgroupInclusiveAdd:
            return "subgroupInclusiveAdd";
        case BuiltinFn::kSubgroupExclusiveAdd:
            return "subgroupExclusiveAdd";
        case BuiltinFn::kSubgroupMul:
            return "subgroupMul";
        case BuiltinFn::kSubgroupInclusiveMul:
            return "subgroupInclusiveMul";
        case BuiltinFn::kSubgroupExclusiveMul:
            return "subgroupExclusiveMul";
        case BuiltinFn::kSubgroupAnd:
            return "subgroupAnd";
        case BuiltinFn::kSubgroupOr:
            return "subgroupOr";
        case BuiltinFn::kSubgroupXor:
            return "subgroupXor";
        case BuiltinFn::kSubgroupMin:
            return "subgroupMin";
        case BuiltinFn::kSubgroupMax:
            return "subgroupMax";
        case BuiltinFn::kSubgroupAll:
            return "subgroupAll";
        case BuiltinFn::kSubgroupAny:
            return "subgroupAny";
        case BuiltinFn::kQuadBroadcast:
            return "quadBroadcast";
        case BuiltinFn::kQuadSwapX:
            return "quadSwapX";
        case BuiltinFn::kQuadSwapY:
            return "quadSwapY";
        case BuiltinFn::kQuadSwapDiagonal:
            return "quadSwapDiagonal";
        case BuiltinFn::kSubgroupMatrixLoad:
            return "subgroupMatrixLoad";
        case BuiltinFn::kSubgroupMatrixStore:
            return "subgroupMatrixStore";
        case BuiltinFn::kSubgroupMatrixMultiply:
            return "subgroupMatrixMultiply";
        case BuiltinFn::kSubgroupMatrixMultiplyAccumulate:
            return "subgroupMatrixMultiplyAccumulate";
        case BuiltinFn::kPrint:
            return "print";
    }
    return "<unknown>";
}

bool IsCoarseDerivative(BuiltinFn f) {
    return f == BuiltinFn::kDpdxCoarse || f == BuiltinFn::kDpdyCoarse ||
           f == BuiltinFn::kFwidthCoarse;
}

bool IsFineDerivative(BuiltinFn f) {
    return f == BuiltinFn::kDpdxFine || f == BuiltinFn::kDpdyFine || f == BuiltinFn::kFwidthFine;
}

bool IsDerivative(BuiltinFn f) {
    return f == BuiltinFn::kDpdx || f == BuiltinFn::kDpdy || f == BuiltinFn::kFwidth ||
           IsCoarseDerivative(f) || IsFineDerivative(f);
}

bool IsTexture(BuiltinFn f) {
    return IsImageQuery(f) ||                                //
           f == BuiltinFn::kTextureGather ||                 //
           f == BuiltinFn::kTextureGatherCompare ||          //
           f == BuiltinFn::kTextureLoad ||                   //
           f == BuiltinFn::kTextureSample ||                 //
           f == BuiltinFn::kTextureSampleBaseClampToEdge ||  //
           f == BuiltinFn::kTextureSampleBias ||             //
           f == BuiltinFn::kTextureSampleCompare ||          //
           f == BuiltinFn::kTextureSampleCompareLevel ||     //
           f == BuiltinFn::kTextureSampleGrad ||             //
           f == BuiltinFn::kTextureSampleLevel ||            //
           f == BuiltinFn::kTextureStore || f == BuiltinFn::kInputAttachmentLoad;
}

bool IsImageQuery(BuiltinFn f) {
    return f == BuiltinFn::kTextureDimensions || f == BuiltinFn::kTextureNumLayers ||
           f == BuiltinFn::kTextureNumLevels || f == BuiltinFn::kTextureNumSamples;
}

bool IsDataPacking(BuiltinFn f) {
    return f == BuiltinFn::kPack4X8Snorm || f == BuiltinFn::kPack4X8Unorm ||
           f == BuiltinFn::kPack2X16Snorm || f == BuiltinFn::kPack2X16Unorm ||
           f == BuiltinFn::kPack2X16Float;
}

bool IsDataUnpacking(BuiltinFn f) {
    return f == BuiltinFn::kUnpack4X8Snorm || f == BuiltinFn::kUnpack4X8Unorm ||
           f == BuiltinFn::kUnpack2X16Snorm || f == BuiltinFn::kUnpack2X16Unorm ||
           f == BuiltinFn::kUnpack2X16Float;
}

bool IsBarrier(BuiltinFn f) {
    return f == BuiltinFn::kWorkgroupBarrier || f == BuiltinFn::kStorageBarrier ||
           f == BuiltinFn::kTextureBarrier;
}

bool IsAtomic(BuiltinFn f) {
    return f == BuiltinFn::kAtomicLoad || f == BuiltinFn::kAtomicStore ||
           f == BuiltinFn::kAtomicAdd || f == BuiltinFn::kAtomicSub || f == BuiltinFn::kAtomicMax ||
           f == BuiltinFn::kAtomicMin || f == BuiltinFn::kAtomicAnd || f == BuiltinFn::kAtomicOr ||
           f == BuiltinFn::kAtomicXor || f == BuiltinFn::kAtomicExchange ||
           f == BuiltinFn::kAtomicCompareExchangeWeak;
}

bool IsPacked4x8IntegerDotProductBuiltin(BuiltinFn f) {
    return f == BuiltinFn::kDot4I8Packed || f == BuiltinFn::kDot4U8Packed ||
           f == BuiltinFn::kPack4XI8 || f == BuiltinFn::kPack4XU8 ||
           f == BuiltinFn::kPack4XI8Clamp || f == BuiltinFn::kPack4XU8Clamp ||
           f == BuiltinFn::kUnpack4XI8 || f == BuiltinFn::kUnpack4XU8;
}

bool IsSubgroup(BuiltinFn f) {
    switch (f) {
        case BuiltinFn::kSubgroupBallot:
        case BuiltinFn::kSubgroupElect:
        case BuiltinFn::kSubgroupBroadcast:
        case BuiltinFn::kSubgroupBroadcastFirst:
        case BuiltinFn::kSubgroupShuffle:
        case BuiltinFn::kSubgroupShuffleXor:
        case BuiltinFn::kSubgroupShuffleUp:
        case BuiltinFn::kSubgroupShuffleDown:
        case BuiltinFn::kSubgroupAdd:
        case BuiltinFn::kSubgroupInclusiveAdd:
        case BuiltinFn::kSubgroupExclusiveAdd:
        case BuiltinFn::kSubgroupMul:
        case BuiltinFn::kSubgroupInclusiveMul:
        case BuiltinFn::kSubgroupExclusiveMul:
        case BuiltinFn::kSubgroupAnd:
        case BuiltinFn::kSubgroupOr:
        case BuiltinFn::kSubgroupXor:
        case BuiltinFn::kSubgroupMin:
        case BuiltinFn::kSubgroupMax:
        case BuiltinFn::kSubgroupAll:
        case BuiltinFn::kSubgroupAny:
        case BuiltinFn::kQuadBroadcast:
        case BuiltinFn::kQuadSwapX:
        case BuiltinFn::kQuadSwapY:
        case BuiltinFn::kQuadSwapDiagonal:
            return true;
        default:
            return false;
    }
}

bool HasSideEffects(BuiltinFn f) {
    switch (f) {
        case BuiltinFn::kAtomicAdd:
        case BuiltinFn::kAtomicAnd:
        case BuiltinFn::kAtomicCompareExchangeWeak:
        case BuiltinFn::kAtomicExchange:
        case BuiltinFn::kAtomicMax:
        case BuiltinFn::kAtomicMin:
        case BuiltinFn::kAtomicOr:
        case BuiltinFn::kAtomicStore:
        case BuiltinFn::kAtomicSub:
        case BuiltinFn::kAtomicXor:
        case BuiltinFn::kTextureStore:
            return true;
        default:
            break;
    }
    return false;
}

}  // namespace tint::core
