// This script accepts the following parameters:
//
// filament_tools_dir
//     Path to the Filament distribution/install directory for desktop
//     (produced by make/ninja install). This directory must contain bin/matc
//
// Example:
//     ./gradlew -Pfilament_tools_dir=../../dist-release assembleDebug

import java.nio.file.Paths
import org.gradle.internal.os.OperatingSystem
import org.gradle.api.logging.Logger;
import org.gradle.api.logging.LogLevel;

def filamentToolsPath = file("../../../../out/release/filament")
if (project.hasProperty("filament_tools_dir")) {
    filamentToolsPath = file("$filament_tools_dir")
}

def matc = ['/bin/matc.exe', '/bin/matc']
def matcFullPath = matc.collect { path -> Paths.get(filamentToolsPath.absolutePath, path).toFile() }

// Ensure that at least one matc binary and Filament library is present
if (!matcFullPath.any { path -> file(path).exists() }) {
    throw new StopActionException("No matc binary could be found in " + filamentToolsPath +
            "/bin. Ensure Filament has been built/installed before building this app.")
}


class LogOutputStream extends ByteArrayOutputStream {
    private final Logger logger;
    private final LogLevel level;

    public LogOutputStream(Logger logger, LogLevel level) {
        this.logger = logger;
        this.level = level;
    }

    public Logger getLogger() {
        return logger;
    }

    public LogLevel getLevel() {
        return level;
    }

    @Override
    public void flush() {
        logger.log(level, toString());
        reset();
    }
}

// Custom task to compile material files using matc
// This task handles incremental builds
class MaterialCompiler extends DefaultTask {
    @Input
    File matcPath

    @SuppressWarnings("GroovyUnusedDeclaration")
    @InputDirectory
    File inputDir

    @OutputDirectory
    File outputDir

    @SuppressWarnings("GroovyUnusedDeclaration")
    @TaskAction
    void execute(IncrementalTaskInputs inputs) {
        if (!inputs.incremental) {
            project.delete(project.fileTree(outputDir).matching { include '*.filamat' })
        }

        inputs.outOfDate { InputFileDetails outOfDate ->
            def file = outOfDate.file

            def out = new LogOutputStream(logger, LogLevel.INFO)
            def err = new LogOutputStream(logger, LogLevel.ERROR)

            def header = ("Compiling material " + file + "\n").getBytes()
            err.write(header)
            out.write(header)

            project.exec {
                standardOutput out
                errorOutput err
                executable "${matcPath}"
                args('-O', '-p', 'mobile', '-o', getOutputFile(file), file)
            }
        }

        inputs.removed { InputFileDetails removed ->
            getOutputFile(removed.file).delete()
        }
    }

    File getOutputFile(final File file) {
        return new File(outputDir, file.name[0..file.name.lastIndexOf('.')] + 'filamat')
    }
}

task compileMaterials(type: MaterialCompiler) {
    group 'Filament'
    description 'Compile materials'

    inputDir = file("src/main/materials")
    outputDir = file("src/main/assets/materials")
    matcPath = OperatingSystem.current().isWindows() ? matcFullPath[0] : matcFullPath[1]
}
